{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Steane Code</p>"},{"location":"3-qubit%20code/","title":"3 qubit code","text":""},{"location":"3-qubit%20code/#idea","title":"Idea","text":"<p>Distribute an arbitrary quantum state $|\\psi \\rangle=\\alpha|0\\rangle+\\beta|1\\rangle$ over an entangled state of $n=3$ physical qubits. $\\Rightarrow$ Encode $k=1$ logical qubit: Basis states or codewords $|0\\rangle_L=|000\\rangle, |1\\rangle_L=|111\\rangle$ span the codespace, a subspace of the Hilbert space, in which arbitrary logical superpositions live: $|\\psi\\rangle_L=\\alpha|0\\rangle_L+|1\\rangle_L=\\alpha|000\\rangle + \\beta|111\\rangle$</p>"},{"location":"3-qubit%20code/#algorithm-steps","title":"Algorithm Steps","text":"<ol> <li>Encoding: quantum circuit $U_\\text{enc}: |\\psi\\rangle\\rightarrow|\\psi\\rangle_L$     Use two Ancilla qubits initialized in $|0\\rangle$:          $|\\psi\\rangle|0\\rangle|0\\rangle\\rightarrow|\\psi\\rangle_L$</li> <li>Possible occurrence of errors:     E.g. bit flip error on qubit 1: $X_1$     $|\\psi\\rangle_L = \\alpha|000\\rangle + \\beta|111\\rangle\\xrightarrow{X_1}\\alpha|100\\rangle+\\beta|011\\rangle$     How can we find out about the error that occurred on the system?<ul> <li>Direct measurement of all qubits would collapse the state into $|100\\rangle$ or $|011\\rangle$: Information about $\\alpha$ and $|\\beta\\rangle$ would be lost.</li> <li>Solution: we realize an indirect measurement, using additional ancilla qubits and syndromes (measurements) $M_z^{(1)}$ and $M_z^{(2)}$</li> </ul> </li> </ol>"},{"location":"3-qubit%20code/#circuit-implementation","title":"Circuit implementation","text":""},{"location":"3-qubit%20code/#errors","title":"Errors","text":"Error $M_z^{(1)}(Z_1Z_2)$ $M_z^{(2)}(Z_2Z_3)$ Correction $X_1$ -1 +1 $X_1$ $X_2$ -1 -1 $X_2$ $X_3$ +1 -1 $X_3$ $\\Rightarrow$ No information gained about the encoded state ($\\alpha$ and $\\beta$ coefficients) $\\Rightarrow$ Strategy corrects up to one $X$-error on any qubit 2 simultaneous errors induce a logical bit flip error Example $X_1X_2$ error: $M_z^{(1)}=+1,M_z^{(2)}=-1$ $\\alpha 110\\rangle + \\beta 001\\rangle \\xrightarrow{X_3} \\alpha 111\\rangle + \\beta $\\Rightarrow$ QER fails For 3 simultaneous errors $X_1X_2X_3$: is not detectable and directly induces a logical bit flip error. Phase flip errors, e.g. $Z_1$ also is undetectable and directly induces a logical phase flip error. $\\Rightarrow$ 3-qubit code is not a complete code."},{"location":"3-qubit%20code/#robustness","title":"Robustness","text":"<p>The probability to correct error(s) is the following: $p_\\text{corr}=(1-p)^3+3p(1-p)^2=1-3p^2+2p^3$ </p> <p>Here for $p&lt;\\frac{1}{2}$, $p_\\text{corr} &gt; 1-p$, thus better protection offered by 3-qubit code.</p>"},{"location":"3-qubit%20code/#stabilizer-code","title":"Stabilizer code","text":"<p>The 3-qubit code can be formulated as a stabilizer QEC code: $$ \\left.</p> <p>\\begin{array}{l}</p> <p>S_1=Z_1Z_2 \\</p> <p>S_2=Z_2Z_3</p> <p>\\end{array}</p> <p>\\right} \\quad S_i|\\psi\\rangle_L=|\\psi\\rangle_L $$ </p> <p>The logical operators are $Z_L=Z_1Z_2Z_3$ and $X_L=X_1X_2X_3$</p>"},{"location":"9-qubit%20Shor%20code/","title":"9 qubit Shor code","text":"<p>It is a $[9,1,1]]$ code based on the concatenation of the 3-qubit repetition code in the [[Z Gate|Z-]] and [X Gate|X-Basis:  Explicit form of logical state: $$ \\begin{align} |\\psi\\rangle_L &amp;=\\alpha(|000\\rangle+|111\\rangle)(|000\\rangle+|111\\rangle)(|000\\rangle+|111\\rangle)/\\sqrt{8} \\ &amp;+ \\beta(|000\\rangle-|111\\rangle)(|000\\rangle-|111\\rangle)(|000\\rangle-|111\\rangle)/\\sqrt{8} \\ &amp;= \\alpha|0\\rangle_L+\\beta|1\\rangle_L \\end{align} $$ - Bit flip errors $X_i$ are corrected by measuring $Z$-stabilizers: ${Z_1Z_2,Z_2Z_3,Z_4Z_5,Z_5Z_6,Z_7Z_8,Z_8Z_9}$ - Phase flip errors $Z_i$ are detected by measuring $X$-stabilizers ${X_1X_2X_3X_4X_5X_6, X_4X_5X_6X_7X_8X_9}$ Properties: - Complete code: arbitrary error correctable - Degenerate code: several errors (e.g. $Z_1$ and $Z_2$ and $Z_3$) have the same effect on logical states. - Correction works if: correction attempt+ error=identity or a stabilizer $S$ - not-perfect/optimal: Quantum Hamming Bound says $\\sum_{j=0}^1\\binom{9}{j}3^j\\cdot2^1 \\leq 2^9 \\Leftrightarrow 28 \\leq 256$, thus the stabilizers span a subspace higher than needed in theory</p>"},{"location":"Computational%20Complexity/","title":"Computational Complexity","text":""},{"location":"Computational%20Complexity/#complexity-class-p","title":"Complexity Class P","text":"<p>Problems for which finding a solution can be achieved in time that scales polynomials with the size of the problem Examples: - Eulerian Path Problem (K\u00f6nigsberg Bridge Problem)</p>"},{"location":"Computational%20Complexity/#complexity-class-np","title":"Complexity Class NP","text":"<p>Problems for which a solution can be found by a non-deterministic (N) Turing machine in polynomial (P) time.</p> <p>However, solutions can still be checked in polynomial time.</p> <p>Examples: - Hamiltonian Cycle Problem - Finding a needle in a haystack - Knapsack problem (NP-Complete) - Sudoku</p> <p>A problem B is NP-complete, if for any problem A in NP there exists a polynomial-time reduction from A to B</p>"},{"location":"Computational%20Complexity/#complexity-class-bqp","title":"Complexity Class BQP","text":"<p>Bounded-error quantum polynomial time is the class of decision problems solvable by a quantum computer in polynomial time, with an error probability of at most 1/3 for all instances.</p> <p>Examples: - Grover</p>"},{"location":"Computational%20Complexity/#efficiency-diagram","title":"Efficiency Diagram","text":"<p>Efficient Quantum Algorithms.canvas|Efficient Quantum Algorithms</p>"},{"location":"Kitaev%E2%80%98s%20toric%20code/","title":"Kitaev\u2018s toric code","text":"<ul> <li>Most commonly studied and experimentally pursued topological Quantum Error Correction|QEC code (experimental variant: \u201esurface code\u201c)</li> <li>$L \\times L$ square lattice with physical qubits located on the edges: </li> <li>The vertices are a star operator and correspond to the action of the two qubits around them</li> <li>All Quantum Error Correction#Stabilizer formalism|stabilizers mutually commute:     $[S_Z^{(i)},S_Z^{j}]=[S_X^{(i)},S_X^{j}] \\quad \\forall i,j$      $[S_X^{(i)},S_Z^{j}]=0 \\quad \\forall i,j$, because plaquette and vertex operators share zero or two qubits (even number of anticommutes)</li> <li>They define the codespace: $S_Z^{(i)}|\\psi\\rangle_L=S_X^{(j)}|\\psi\\rangle_L=|\\psi\\rangle_L$</li> <li>Here we consider lattice with periodic boundary conditions, i.e. embedded on the surface of a torus $\\Rightarrow$ toric code</li> </ul>"},{"location":"Kitaev%E2%80%98s%20toric%20code/#number-of-encoded-logical-qubits-and-logical-operators","title":"Number of encoded logical qubits and logical operators","text":"<p>The number of logical qubits can be determined by counting the number of physical qubits and independent constraints: - $L^2$ plaquettes $\\Rightarrow$ $n^2=2L^2$ physical qubits (they re on the edges) - $L^2$ plaquettes $\\Rightarrow$ $L^2$ Z-stabilizers - $L^2$ vertices $\\Rightarrow$ $L^2$ X-stabilizers</p> <p>However, not all stabilizers are independent, the $L^2$-th stabilizer is redundant: $\\prod_i S_Z^{(i)}=\\mathbb{I} \\quad \\Rightarrow \\prod_{i=1}^{L^2-1}S_Z^{(i)} = S_Z^{(L^2)}$ $\\prod_i S_X^{(i)}=\\mathbb{I} \\quad \\Rightarrow \\prod_{i=1}^{L^2-1}S_X^{(i)} = S_X^{(L^2)}$ $\\Rightarrow$ Only $2(L^2-1)$ independent X,Z-stabilizers</p> <p>This yields for $k=n-\\text{# independent constraints}=(2L^2)-2(L^2-1)=2$</p> <p>The toric code can host 2 encoded logical qubits. This is a topological property, and independent of the lattice size or lattice structure (square lattice, hexagonal lattice, etc.)</p> <p>Logical operators ${Z_L^{(1)},Z_L^{(2)},X_L^{(1)},X_L^{(2)}}$ correspond to non.contractable string operators winding around the hole and the handle of the torus: </p> <p></p> <ul> <li>All string operators commute with all stabilizers: $[O_L,S^{(i)}]=0 \\quad \\checkmark$<ul> <li>$Z_L^{(1)}$ and $Z_L^{(2)}$ touch an even number of vertices, the first half and last half of the vertex is combined to one full vertex in the torus</li> <li>$X_L^{(1)}$ and $X_L^{(2)}$ touch an even number of plaquettes</li> </ul> </li> <li>$X_L^{(i)}$ and $Z_L^{(i)}$ of the same encoded qubit anticommute as required: ${X_L^{(i)},Z_L^{(i)}}=0 \\quad i=1,2 \\quad \\checkmark$<ul> <li>They share exactly one single physical qubit and thus the number of anticommutes is uneven</li> </ul> </li> <li>Logical operators of different needed qubits commute as required:     $[Z_L^{(1)},Z_L^{(2)}]=[X_L^{(1)},X_L^{(2)}]=0$     $[Z_L^{(1)},X_L^{(2)}]=[X_L^{(1)},Z_L^{(2)}]=0$     thus $[O_L^{(1)},O_L^{(2)}]=0 \\quad \\checkmark$</li> <li>Note that logical operators don\u2018t have unique qubit support (which means that they do not reach any arbitrary qubit normally) but can be deformed by multiplication with stabilizer operators which act trivially on logical states:</li> <li> The deformed operators have the same action on logical states:</li> </ul> <p>$\\tilde{Z}_L^{(1)}|\\psi\\rangle_L=Z_L^{(1)}S_Z|\\psi\\rangle_L=Z_L^{(1)}|\\psi\\rangle_L$</p> <p>Commutation and anticommutation relations are preserved under such continuous deformations: </p> <p>Finally, one can write the logical basis states explicitly in the Z-Basis: $$ \\begin{align} |0\\rangle_L^{(1)}|0\\rangle_L^{(2)} &amp;\\propto \\frac{1}{2} (\\mathbb{I}+Z_L^{(1)})\\frac{1}{2} (\\mathbb{I}+Z_L^{(2)}) \\prod_+ \\frac{1}{2} (\\mathbb{I}+S_X^{(+)})\\prod_\\Box\\frac{1}{2} (\\mathbb{I}+S_Z^{(\\Box)})|0\\rangle^{\\otimes n} \\ &amp;= \\prod_+ \\frac{1}{2} (\\mathbb{I}+S_X^{(+)})\\frac{1}{2}(\\mathbb{I}+Z_L^{(1)})\\frac{1}{2} (\\mathbb{I}+Z_L^{(2)})\\prod_\\Box\\frac{1}{2} (\\mathbb{I}+S_Z^{(\\Box)}) |0\\rangle^{\\otimes n}\\ &amp;=\\prod_+ \\frac{1}{2} (\\mathbb{I}+S_X^{(+)}) |0\\rangle^{\\otimes n}\\ |1\\rangle_L^{(1)}|0\\rangle_L^{(2)} &amp;= X_L^{(1)} |0\\rangle_L^{(1)}|0\\rangle_L^{(2)} \\ \\end{align} $$ Intuitively the following happens: We maximize the deformations of the strings, we can change the order of the terms because the logical operators commute with the stabilizers. The string could be deformed again generally. But in this case the $|0\\rangle^{\\otimes n}$ state is the eigenstate for the projector of the $Z$-basis for all qubits, so we get an eigenvalue +1 for those projectors, so only the $S_X^{(+)}$ projectors remain. Remember that the last stabilizer is redundant and doesn\u2018t change the subspace of the projectors, meaning that the eigenvalues of the stabilizers already have been considered. Example L=2: $$ \\begin{aligned}</p> <p>\\Bigg(\\prod_{i=1}^{4}\\frac{\\mathbb{I}+S_X^{(i)}}{2}\\Bigg)\\,|0\\rangle^{\\otimes 8}</p> <p>&amp;= \\frac{1}{16}\\,( \\mathbb{I}+S_{X1})(\\mathbb{I}+S_{X2})(\\mathbb{I}+S_{X3})(\\mathbb{I}+S_{X4})\\,|0\\rangle^{\\otimes 8}\\</p> <p>&amp;= \\frac{1}{8}\\,( \\mathbb{I}+S_{X1})(\\mathbb{I}+S_{X2})(\\mathbb{I}+S_{X3})\\,|0\\rangle^{\\otimes 8} \\qquad</p> <p>\\big(S_{X4}=S_{X1}S_{X2}S_{X3}\\big)\\[4pt]</p> <p>&amp;= \\frac{1}{8}\\big(\\mathbb{I}+S_{X1}+S_{X2}+S_{X3}</p> <p>+S_{X1}S_{X2}+S_{X1}S_{X3}+S_{X2}S_{X3}+S_{X1}S_{X2}S_{X3}\\big)\\,|0\\rangle^{\\otimes 8}\\[4pt]</p> <p>&amp;= \\frac{1}{8}\\big(</p> <p>|00000000\\rangle+|11100010\\rangle+|00011101\\rangle+|11010001\\rangle\\</p> <p>&amp;\\qquad\\qquad\\quad\\\u00a0</p> <p>+|11111111\\rangle+|11001100\\rangle+|00110011\\rangle+|00101110\\rangle</p> <p>\\big)</p> <p>\\end{aligned} $$</p>"},{"location":"Kitaev%E2%80%98s%20toric%20code/#qec-using-the-toric-code","title":"QEC using the toric code","text":"<ul> <li>Errors on physical qubit show up as stabilizer \u201eexcitations\u201c (i.e. indirect measurement|-1 eigenvalue measurements) of adjacent plaquette and vertex operators:</li> <li>Idea: Syndrome information is used to make best possible guess about the homological class of the set of errors which have occurred on the system<ul> <li>Errors are created randomly and can diffuse</li> <li>We want to detect the errors quickly and reliably, and keep them localized and remove them</li> </ul> </li> </ul> <p>The error correction succeeds iff the loop $X_L=C+E$ (Correction attempt $C$ + Error chain $E$) is a contractable loop. Note, that the error chain is unknown. This is equivalent to a concatenation of Quantum Error Correction#Stabilizer formalism|stabilizer operators which don\u2018t change the codespace per definition. A non contractable loop leads to a logical operation equivalent to a logical error.</p>"},{"location":"Kitaev%E2%80%98s%20toric%20code/#robustness-of-the-toric-code","title":"Robustness of the toric code","text":"<ul> <li>Independently distributed, stochastic bit and phase flip errors on physical qubits occurring with probability $p$ can be corrected as long as $p&lt;p_c=10.9\\%$.</li> <li>Decoding (i.e. determining a correction attempt given an error syndrome) an be done e.g. using the minimum-weight matching (MWPM) algorithm: find correction chain with overall shortest length </li> </ul> <p>Surface Code|Planar surface codes are the physical implementation for the toric code.</p>"},{"location":"Later%20notes/","title":"Later notes","text":"<p>To make a transformation deterministic one can introduce an Ancilla which flags or encodes the success or fail probability. $U : |\\psi\\rangle_\\text{sys} \\otimes |0\\rangle_\\text{anc} \\to \\sum_i (T_i |\\psi\\rangle_\\text{sys}) \\otimes |i\\rangle_\\text{anc}$</p>"},{"location":"No-Cloning%20Theorem/","title":"No Cloning Theorem","text":"<p>[!IMPORTANT] There exists no physical procedure to copy any arbitrary quantum state $|\\psi \\rangle$</p> <p>Proof: Imagine that such an operation $U$ exists, which performs the following map:</p> <p>Consider two input states $|\\psi \\rangle$ and $|\\phi \\rangle$: $|\\psi \\rangle | s \\rangle \\xrightarrow{U} |\\psi \\rangle |\\psi \\rangle$ $|\\phi \\rangle | s \\rangle \\xrightarrow{U} |\\phi \\rangle |\\phi \\rangle$</p> <p>$|\\psi \\rangle |\\psi \\rangle = U |\\psi \\rangle | s \\rangle$ $|\\phi \\rangle |\\phi \\rangle = U |\\phi \\rangle | s \\rangle$</p> <p>Take the inner product: $(\\langle \\psi|\\langle \\psi|)(|\\phi \\rangle |\\phi \\rangle) =\\langle \\psi|\\langle s|U^\\dagger U|\\phi \\rangle |s \\rangle$ $\\Rightarrow \\langle \\psi | \\phi \\rangle^2 = \\langle \\psi | \\phi \\rangle \\langle s | s \\rangle$ $\\Rightarrow \\langle \\psi | \\phi \\rangle^2 = \\langle \\psi | \\phi \\rangle$ which is only true, if $|\\psi \\rangle$ and $|\\phi \\rangle$ are either equal or orthogonal $\\Rightarrow$ We can't copy states $|\\psi \\rangle$ and $|\\phi \\rangle$ that are not orthogonal.</p>"},{"location":"Overview/","title":"Overview","text":""},{"location":"Overview/#lectures","title":"Lectures","text":"<p>BLOCK 1\u00a0(tentative list of topics covered)</p> <p>1 - Overview and Introduction</p> <p>2 - Quantum Gates and Circuits</p> <p>3-A - Deutsch Algorithm</p> <p>3-B - Deutsch-Jozsa Algorithm and Bernstein-Vazirani Problem</p> <p>4 - Classical Computation 5 - Universality of Quantum Gates 6 - Computational Complexity 7 - Grover Quantum Search Algorithm 8 - Quantum Fourier Transform 9 - Quantum Phase Estimation 10 - Quantum Order Finding 11-A - Shor Algorithm for Factoring  </p> <p>BLOCK 2</p> <p>Lecture 1 : Rules of Quantum Theory We formulate rules of quantum theory characterizing what is possible and what is not, making the role of information explicit.</p> <p>\u2022 For open quantum \u201dsystems\u201d some information got lost : Non-pure events / circuits require a mathematically more complicated description which is, however, closer to an operational understanding of what goes on in the physics lab and to classical theory</p> <p>\u2022 For closed quantum \u201dsystems\u201d there is no information that can get lost : Pure events allow a mathematically simpler description which is, however, not directly related to the physics in the lab or classical theory</p> <p>We explore several ways these two formalisms are related. The goal is to master both and to be able switch between them at will.</p> <p>The quantum rules mathematically contruct probabilities from Hilbert-space vectors/operators subject to a physical contraint of causality. But other than this, the rules of quantum theory are simply mathematically postulated without any deeper physical motivation beyond \u201cexperiments con\ufb01rm their predictions\u201d. This leaves us to \u201cdiscover the physics\u201d by solving operational tasks of information processing. This is what Lecture 2-5 do systematically.</p> <p>Terminology State vectors, density operators, ensembles, POVMs, channels, operations, instruments, isometries, non-orthogonal sets</p> <p>Lecture 2 : Observations on Preparations With the quantum rules in hand we \ufb01rst study the simplest quantum circuit where a single system A is prepared and then observations are performed to extract information contained in their joint probabilities :</p> <ol> <li> <p>We verify that the closed-system rules indeed only describe pure preparations based on the simulatability of the probability distributions that they can generate, and likewise for observations.</p> </li> <li> <p>We then analyze non-pure preparations of open systems by bringing these into a standard simulation form, identifying what is \u201cquantum\u201d about them, and likewise for observations :</p> </li> </ol> <p>\u2022 Non-pure preparations are always mixtures with information encoded in the probabilities of mixing (like classically) but also in the freedom of choice of the pure states that are being mixed (unlike classically)</p> <p>\u2022 Non-pure observation are always coarse-grainings involving pure observations (like classically) but the freedom of choosing these prohibits the simulation of any measurement by post-processing of a single pure observation device (unlike classically)</p> <p>This \u201cNon-uniqueness of prepation re\ufb01nement\u201d and \u201cNo post-processings of ideal measurement\u201d turn out to be the same thing.</p> <ol> <li>We then analyze 2 basic tasks of information extraction :</li> </ol> <p>\u2022 In tomography, we extract complete information characterizing an unknown preparation by a D-outcome observation on the quantum system</p> <p>\u2022 In perfectly distinguishing, a known set of preparations is identi\ufb01ed by a d-outcome observation device without extracting complete information about these states</p> <p>(\u201cWhich one is it?\u201d)</p> <p>(\u201cWhich of these is it)</p> <p>These task are related by D=d 2 expressing an \u201cinformation gap\u201d : Tomography is quadratically harder than perfectly distinguishing This is the operational signi\ufb01cance of the quantum rule \u201cStates are d\u00d7d positive matrices on a Hilbert space\u201d</p> <p>Terminology Measurement in orthogonal basis, IC-POVMs Lecture 3 : Steering a pure preparation</p> <p>We next consider a quantum circuit where two systems are jointly prepared. A local measurement is performed to extract information from one system B and we investigate what classical communication B\u2192A implies for the description of the other remote system A</p> <ol> <li>With communication, this results in remote steering.</li> </ol> <p>steering</p> <p>The solution of this operational task leads to a characterization of all pure, correlated states These correlations are not simulatable by coarse-graining of coordinated local preparations (unlike classically)</p> <ol> <li>Without communication there is no remote e\ufb00ect as dictated by causality.</li> </ol> <p>The solution of the inverse operational task, puri\ufb01cation, leads to a pure, correlated simulation of any remote non-pure state of an open system (classically impossible). The \u201cnon-uniqueness of mixture re\ufb01nement of preparation\u201d of Lecture 2 is fully characterized.</p> <ol> <li>The non-locality of entanglement is shown to limited by the locality of quantum tomography, the ability to characterize any quantum state by local observations (like classically): Entanglement is monogamous correlation, non-shareable by more than 2 parties</li> </ol> <p>Terminology Entanglement, Schmidt decomposition of bipartite vectors, SVD, partial trace</p> <p>BLOCK 3\u00a0(tentative list of topics covered) 12-A - Basic Concepts of Quantum Error Correction 12-B - Stabiliser Formalism and Complete Codes 13-A - Introduction to Topological QEC Codes 13-B - Fault-Tolerant Universal Gates and Scalable Architectures</p> <p>BLOCK 4</p> <p>Lecture 4-5 systematically performs the analogous steps of Lecture 2-3 for transformations (measurements, evolutions) thereby completing the framework of essential results of quantum information theory :</p> <p>Lecture 4 : Transformations</p> <p>The next level of complexity is a quantum circuit involving transformations of the preparation of a single system. These can extract information about input state A before a further, \ufb01nal observation is made on the disturbed output state B :</p> <ol> <li> <p>We verify that the closed-system rules indeed only describe pure transformations by the simulatability of the probability distributions that they generate. The purity of the identity transformation (\u201ctrivially doing nothing\u201d) implies that nontrivial result that information-extraction implies disturbance of a quantum system, starting from clear-cut de\ufb01nitions based on probabilities in the lab.</p> </li> <li> <p>We analyze non-pure transformations of open systems by again bringing them into a standard simulation form and we identify what is \u201cquantum\u201d about them :</p> </li> </ol> <p>\u2022 A non-pure transformation is always a coarse-grainings of some pure \u201ctransition\u201d processes (like in classical theory) but there is freedom of choice in which \u201ctransitions\u201d are coarse-grained (unlike classical theory)</p> <p>\u2022 A non-pure transformation need not be a mixture (like classical theory)</p> <p>This \u201cnon-uniqueness of re\ufb01nement\u201d of transformations is remiscent of that of for states. This is no coincidence :</p> <ol> <li>We again analyze 2 basic tasks of information extraction :</li> </ol> <p>\u2022 Tomography, extracting complete information characterizing an unknown transformation, turns out to be possible by \u201cencoding\u201d the transformation in its modi\ufb01cation of pure entangled state and \u201cdecoding\u201d it by using the corresponding state as resource for teleportation of input to output</p> <p>\u2022 Perfectly distinguishing a known set of transformations likewise turns out to be possible by perfectly distinguishing these corresponding states</p> <p>(\u201cWhich one is it?\u201d)</p> <p>(\u201cWhich of these is it?\u201d)</p> <p>The uncovered preparation-transformation correspondence is a key trick that allows to convert any result about preparations into a result about transformations and vice versa. This is systematically exploited in the \ufb01nal lecture.</p> <p>Terminology Kraus operators, (Sudarshan-)Kraus theorem, (de Pillis-)Choi-Jamiolkowski correpondence, HEWJ theorem Lecture 5 : Steering a pure transformation</p> <p>Finally, the most complex quantum circuit we need to consider involves transformations jointly preparing two output systems AB taking input from one system C. A local measurement is applied to extract information from one output B and we investigate what classical communication B\u2192A implies for the transformation outputting to the remote system A :</p> <p>steering</p> <ol> <li>With communication, this results in remote transformation steering.</li> </ol> <p>The solution of this operational task leads to characterization of pure entanglement generating transformations</p> <ol> <li>Without communication there is no remote e\ufb00ect as dictated by causality.</li> </ol> <p>The solution of the inverse operational task, transformation puri\ufb01cation, leads to a pure simulation of any non-pure transformation with remote output (classically impossible). The \u201cnonuniqueness of transformation re\ufb01nement\u201d in Lecture 4 is fully characterized.</p> <ol> <li>The non-locality of entanglement generation is likewise shown to limited by the locality of quantum tomography : Entanglement is monogamous correlation, non-shareable by more than 2 parties.</li> </ol> <p>Terminology Schmidt decomposition of isometries, Stinespring dilation, channels, operations, instruments</p> <p>What will we learn ?</p> <p>By systematically analyzing very basic operational tasks allowed by the rules of quantum theory and switching back and fort between closed- and open-system formalisms, we will derive all essential results in quantum information theory. In doing so, we illustrate :</p> <p>Quantum theory is all about information. Quantum circuits are the calculations.</p> <p>We stress that all the results can be \u2013and often are\u2013 derived in mathematical style and discussed in purely mathematical language. This is not wrong, but it does leave the reader interested in physics to \ufb01gure out what it is all about.</p> <p>However, we will see time and again that the mathematics naturally follows from the operational physics. This is not a coincidence : All of the mathematics of quantum theory (\ufb01nite dimension, without superselection) can be derived by solving the information processing tasks discussed in this lecture, starting from a few operational de\ufb01nitions and manipulating quantum circuits.</p>"},{"location":"Overview/#exercises","title":"Exercises","text":"<p>BLOCK 1</p> <p>1.1 Circuit identities (few simple identities/rules) 1.2 SWAP gates (proof of swap gates and implementation from cnot, does swap gate create entanglement) 1.3 Deutsch algorithm (implementation) 1.4 Deutsch Josza algorithm (implementation) 2.1 Bernstein Vazirani (implementation) 2.3 Controlled-U gates )(controlled U Gate construction from single qubit unitaries) 3.1 n-controlled U gates (Implementation via controlled Vs, logical expression equivalent) 3.2 Grover 2-bit (Implementation) 3.3 Grover 3-bit (Implementation and optimal k) 4.1 Phase estimation (Alternative iterative approach) 4.2 Single qubit measurements on multipartite states (creation of GHZ and W-state with circuits) 4.3 Decomposition of multi qubit unitaries (Implementation of grey code) 5.1 Magic state and T-state injection 5.2 Shor\u2018s algorithm (Doing algorithm per hand) 5.3 Universal gate sets (alternative gate sets)</p> <p>BLOCK 2</p> <p>6.1 Physical validity of mathematical expressions 6.2\u00a0Ensemble tomography with orthogonal measurements  </p> <p>7.1 Conclusively distinguishing distinct states   7.3 Tomographic preparation device</p> <p>8.1 Conclusively distinguishing \u2013 Implementations</p> <p>10.1 Basic qubit \u201cnoise\u201d channels  </p> <p>BLOCK 3</p> <p>10.2 Quantum Error Correction (QEC) with a 7-Qubit Steane Code (How $7,1,3$ works and constructing other logical gates (e.g. $H_L$))</p> <p>11.1 Quantum error correction of qubit loss (How it works and implementation)</p> <p>Block 4</p> <p>12.1 Correspondence Bell states \u2194 Pauli transformations 12.2 Teleportation and communication</p>"},{"location":"Protocols/","title":"Protocols","text":""},{"location":"Protocols/#prof-muller","title":"Prof M\u00fcller","text":""},{"location":"Protocols/#basic-topics","title":"Basic topics","text":"<ul> <li>entangled state example bell state</li> <li>how to construct $\\frac{1}{\\sqrt{2}}(|000\\rangle+|111\\rangle)$</li> <li>how would one create an entangled state $\\frac{1}{\\sqrt{2}}(|000\\rangle+|111\\rangle)$</li> <li>QPE</li> <li>No-cloning Theorem and Proof</li> <li>how to construct $\\frac{1}{\\sqrt{2}}(|000\\rangle+e^{i \\frac{\\pi}{4}}|111\\rangle)$</li> <li>Name a universal gate set</li> <li>How many gates are needed to construct n-qubit unitary<ul> <li>$O(n^24^n)$</li> </ul> </li> <li>what is a rotation gate<ul> <li>show on bloch sphere</li> <li>enough to get  to arbitrary rotations?</li> <li>enough for universality?</li> </ul> </li> <li>is $|+0\\rangle+|-1\\rangle$ entangled?<ul> <li>yes</li> <li>draw circuit</li> </ul> </li> <li>is CNOT, H universal? how to make it universal?</li> <li>given arbitrary U is it efficient to decompose into CNOT H T, complexity?</li> <li>classical computing<ul> <li>nand</li> <li>toffoli</li> </ul> </li> <li>quantum<ul> <li>cnot toffoli</li> </ul> </li> <li>universality<ul> <li>universal set</li> <li>produce X from T  H CNOT</li> </ul> </li> <li>reversible vs irreversible</li> <li>classical &amp; quantum computing<ul> <li>why nand impossible in quantum </li> <li>examples for reversible</li> <li>CNOT from toffoli</li> </ul> </li> <li>can you entangle with swap gate? why?</li> </ul>"},{"location":"Protocols/#intermediate-topics","title":"Intermediate topics","text":"<ul> <li>Grover Algorithm circuit + explain oracle $\\Rightarrow$ how the speedup are (if one does not now calculate)</li> <li>Hammin bound formula</li> <li>order finding</li> <li>Draw order finding circuit<ul> <li>given some numbers what is the order</li> <li>how to factor a number using r</li> </ul> </li> <li>Bernstein Vazirani<ul> <li>circuit</li> <li>compare classic/quantum oracle</li> </ul> </li> <li>NP hard problems<ul> <li>how to speed up?<ul> <li>Grover</li> <li>geometric picture what is the probability after k steps</li> </ul> </li> </ul> </li> <li>Deutsch Josza <ul> <li>explain objective problem</li> <li>oracle</li> <li>circuit</li> <li>how to measure (projective measurement)</li> </ul> </li> <li>Vazirani<ul> <li>Scaling quantum vs classical</li> </ul> </li> <li>QFT<ul> <li>1 qubit</li> <li>2 qubit</li> <li>n qubit gate count definition of R_n</li> </ul> </li> <li>QPE</li> </ul>"},{"location":"Protocols/#advanced-topics","title":"Advanced topics","text":"<ul> <li>What are codes and why one needs it?</li> <li>states losing coherence $\\Rightarrow$ toric code<ul> <li>stabilizer circuit</li> </ul> </li> <li>Explain Steane Code $7,1,3$ with logical operators + sketch non disturbing measurement</li> <li>9 qubit code $9,1,3$<ul> <li>how many logical qubit</li> <li>how many error corrected</li> <li>stabilizers</li> <li>what happens iff certain error happens</li> <li>how to correct error</li> <li>how to measure indirectly</li> <li>is circuit fault tolerant?</li> <li>what is the weight of the error</li> </ul> </li> <li>Color Code (Steane)</li> <li>distance 3 surface code<ul> <li>stabilizers</li> <li>how to measure</li> <li>error propagation, show uncorrectable error</li> </ul> </li> <li>Stabilizer codes<ul> <li>minimum qubits for 1 logical 1 arbitrary error</li> <li>5 qubits</li> <li>write down stabilizers for that</li> </ul> </li> <li>Quantum hamming bond</li> <li>error propagation</li> <li>order finding<ul> <li>shor circuit</li> <li>derive factors</li> </ul> </li> <li>Color code</li> <li>toric code</li> <li>3 qubit code p_corr graph<ul> <li>how to decrease<ul> <li>concatatenation</li> <li>how much improvement</li> </ul> </li> </ul> </li> </ul>"},{"location":"Protocols/#prof-wegwejis","title":"Prof Wegwejis","text":"<ul> <li>General stuff/ less about formulas, writes complex formulas himself and lets you explain them</li> <li>We use the notation now:<ul> <li>observation test (instead of POVM)</li> <li>effect/observation (instead of effect operator)</li> <li>transformations (instad of kraus operators/ canonical coarse graining form)<ul> <li>pure transformation is one kraus operator</li> </ul> </li> <li>Correspondence between superoperators and bipartite operators (instead of Choi-Jamiolkowski)</li> <li>Deterministic preparation= Normalized state  </li> <li>Probabilistic preparation test =Sub-normalized states collected into an ensemble</li> <li>Probabilistic observation test = Effects collected into a positive-operator-valued-measure (POVM), destructive measurement</li> <li>Deterministic transformation = Channel or evolution </li> <li>Probabilistic transformation test = Operations collected into an instrument, measurement, transformation-valued measure</li> </ul> </li> </ul>"},{"location":"Protocols/#basic-topics_1","title":"Basic topics","text":"<ul> <li>POVM Effect operator identity+ Pretty good Operator</li> <li>Effect operators and POVM and how they relate to each other<ul> <li>effectors do not give the state after measurement and how to compute the probability.</li> <li>constraints (semipositivity, sum to unitary)</li> </ul> </li> <li>construct a Pretty good measurement from 3 point in the blochsphere</li> <li>how to prepare an ensemble</li> <li>how to calculate probability in open system</li> <li>what are requirements on transformatioin (CP preserving)<ul> <li>show that it is cp preserving</li> </ul> </li> <li>do a canonicial form  of $\\psi_{AB}$<ul> <li>use steering to get canonical A-basis</li> </ul> </li> <li>open systems definition</li> <li>what does transformkation do to a state</li> <li>represent pure state in canonical basis</li> <li>dreive kraus oeprators from circuits and example</li> <li>constraints of transformation test</li> <li>open systems experiment definition#</li> <li>transformation conditions<ul> <li>$T^\\dagger T\\leq\\mathbb{I}$</li> </ul> </li> <li>does isometric transformation increase/decrease dimension of system</li> <li>closed system definition</li> <li></li> </ul>"},{"location":"Protocols/#intermediate-topics_1","title":"Intermediate topics","text":"<ul> <li>Quantum Channel 1/2(X * X + Z * Z) apply on blochsphere representation =&gt; calculation</li> <li>Distinguishing non-orthogonal states<ul> <li>prove, that measurement operators can not perfectly distinguish non-orthogonal states</li> </ul> </li> <li>steering<ul> <li>explain</li> <li>what about commincation</li> <li>causality</li> </ul> </li> <li>steering</li> <li>steering</li> <li>how to define transfomation<ul> <li>properties <ul> <li>subunit trace preserving</li> </ul> </li> <li>completely positive or enough when only positive?<ul> <li>completely positive</li> </ul> </li> </ul> </li> <li>marginal operators?</li> <li>definition entanglement processing<ul> <li>4 rules</li> </ul> </li> <li>what is entanglement dimension in bipartite system</li> <li>definition entanglement processing<ul> <li>4 rules</li> </ul> </li> <li>how to simulate remote transformation by local transformation? show</li> <li>canonical form of observations and states</li> </ul>"},{"location":"Protocols/#advanced-topics_1","title":"Advanced topics","text":"<ul> <li>no information without disturbance</li> <li>Information = Disturbance:<ul> <li>What does this mean</li> <li>writes down formula, show what the objects are (Measurement and Superoperator)</li> <li>\"No disturbance without communication\"</li> <li>\"No disturbance means no information\"</li> </ul> </li> <li>Deriving Measurement Operators from Evolution and Choi-Jamiolkowski</li> <li>Explain entanglement supping<ul> <li>Explain</li> <li>what is $p_\\psi$</li> <li>upper limit (1/$d^2$)</li> <li>show that $p_\\psi &lt; 1/d^2$<ul> <li>Cauchy Schwartz use $\\sum_n \\lambda_n=1$</li> </ul> </li> </ul> </li> <li>write down maximally entangled state</li> <li>swap operation<ul> <li>trafo not valid</li> </ul> </li> <li>entanglement swapping<ul> <li>circuit</li> <li>write down teleportation</li> </ul> </li> <li>Information = Disturbance</li> <li>information=disturbance</li> <li>what is a non informative transf test<ul> <li>what are proportion?</li> <li>$||T_{AB}|\\psi_A\\rangle\\langle\\psi_A|T_{AB}^\\dagger=|\\psi_A\\rangle\\langle\\psi_A|$</li> </ul> </li> <li>information=disturbance</li> <li>bob and alice quantum teleportation</li> <li>signalling without communication</li> </ul>"},{"location":"Protocols/#summarized-version-from-chatgpt","title":"Summarized version from ChatGPT","text":""},{"location":"Protocols/#prof-muller_1","title":"Prof. M\u00fcller","text":""},{"location":"Protocols/#basic-topics_2","title":"Basic Topics","text":"<ul> <li>Entangled states</li> <li>Example: Bell state</li> <li>Is $|+0\\rangle + |-1\\rangle$ entangled? (Yes, draw circuit)</li> <li>Constructing entangled states</li> <li>$\\frac{1}{\\sqrt{2}} (|000\\rangle + |111\\rangle)$</li> <li>$\\frac{1}{\\sqrt{2}} (|000\\rangle + e^{i\\pi/4} |111\\rangle)$</li> <li>Quantum gates and universality</li> <li>Name a universal gate set</li> <li>Is CNOT + H universal? How to make it universal</li> <li>Gates needed for an n-qubit unitary: $O(n^2 4^n)$</li> <li>Arbitrary $U$ decomposition into CNOT, H, T</li> <li>Rotation gates</li> <li>Bloch sphere representation</li> <li>Arbitrary rotations and universality</li> <li>Classical vs quantum computing</li> <li>NAND, Toffoli, CNOT</li> <li>Reversible vs irreversible</li> <li>Why NAND impossible in quantum</li> <li>Examples of reversible operations</li> <li>Can you entangle with SWAP? Why?</li> <li>No-cloning theorem</li> <li>Proof</li> <li>Quantum Phase Estimation (QPE)</li> </ul>"},{"location":"Protocols/#intermediate-topics_2","title":"Intermediate Topics","text":"<ul> <li>Grover\u2019s algorithm</li> <li>Circuit and oracle</li> <li>Speedup explanation (geometric probability)</li> <li>Hamming bound formula</li> <li>Order finding</li> <li>Circuit</li> <li>How to factor using the order $r$</li> <li>Bernstein-Vazirani</li> <li>Circuit and comparison with classical oracle</li> <li>Deutsch-Jozsa</li> <li>Objective/problem, oracle, circuit</li> <li>Measurement (projective)</li> <li>NP-hard problems</li> <li>Grover speedup</li> <li>Quantum Fourier Transform (QFT)</li> <li>1, 2, n-qubit versions</li> <li>Gate counts</li> <li>Definition of $R_n$</li> </ul>"},{"location":"Protocols/#advanced-topics_2","title":"Advanced Topics","text":"<ul> <li>Quantum error correction</li> <li>Why codes are needed (coherence loss)</li> <li>Stabilizer circuits, Steane Code $7,1,3$</li> <li>9-qubit code $9,1,3$<ul> <li>Logical qubits, error correction, stabilizers</li> <li>Error propagation, indirect measurement, fault tolerance, error weight</li> </ul> </li> <li>Color code (Steane)</li> <li>Distance-3 surface code</li> <li>3-qubit code, concatenation, error probability improvement</li> <li>Minimum qubits for 1 logical qubit correcting arbitrary error (5-qubit code)</li> <li>Shor\u2019s algorithm</li> <li>Order finding, circuit, factor derivation</li> </ul>"},{"location":"Protocols/#prof-wegwejis_1","title":"Prof. Wegwejis","text":""},{"location":"Protocols/#basic-topics_3","title":"Basic Topics","text":"<ul> <li>Notation</li> <li>Observation test (POVM)</li> <li>Effect/effect operator</li> <li>Transformation (instead of Kraus operator)</li> <li>Deterministic vs probabilistic preparation and observation</li> <li>POVM &amp; effect operators</li> <li>Constraints: semipositivity, sum to identity</li> <li>Pretty Good Measurement (PGM) example with 3 Bloch points</li> <li>State preparation and ensembles</li> <li>Open systems</li> <li>Definition, pure vs mixed states, canonical basis</li> <li>Transformation effects on states, Kraus operators from circuits</li> <li>Conditions: $T^\\dagger T \\le I$, CP-preserving</li> <li>Isometric transformations</li> <li>System dimension</li> </ul>"},{"location":"Protocols/#intermediate-topics_3","title":"Intermediate Topics","text":"<ul> <li>Quantum channels</li> <li>Example: $\\frac{1}{2} (X \\cdot X + Z \\cdot Z)$ on Bloch sphere</li> <li>Distinguishing non-orthogonal states (impossibility proof)</li> <li>Steering</li> <li>Communication, causality</li> <li>Simulating remote transformation via local operations</li> <li>Canonical form of states and observations</li> <li>Entanglement processing</li> <li>Definition, rules, entanglement dimension</li> </ul>"},{"location":"Protocols/#advanced-topics_3","title":"Advanced Topics","text":"<ul> <li>No information without disturbance</li> <li>Meaning, formulas (measurement and superoperator)</li> <li>Teleportation, entanglement swapping circuits</li> <li>Non-informative transformation tests</li> <li>Entanglement swapping probabilities</li> <li>Upper limit $1/d^2$, proof using Cauchy-Schwarz</li> <li>Maximally entangled states</li> </ul>"},{"location":"Quantum%20Error%20Correction/","title":"Quantum Error Correction","text":""},{"location":"Quantum%20Error%20Correction/#basics","title":"Basics","text":"<p>The error rates of Quantum computation applications for guaranteed quantum advantage in the fault taulerant regime needed are $10^{-14}/10^{-15}$. This is why Quantum Error Correction is very important in the [Route to large-scale fault tolerant quantum computing.canvas|Route to large-scale fault tolerant quantum computing]]. The coupling to the environment causes decoherence, for example magnetic field fluctuations.  Dephasing can happen in a mixed state in an open system simulated by pure coherent superposition states, which leads to the loss of phase information. Other than that [[X Gate|X-errors]], [[Y Gate|Y-errors]] and [Z Gate|Z-errors could happen as well as leakage and qubit loss.</p>"},{"location":"Quantum%20Error%20Correction/#classical","title":"Classical","text":"<p>In classical error correction redundancies are introduced, for example n-bit repetition code, with majority vote as correction strategy. The repetition code fails if more than half of the bits suffer errors (bit flips).</p>"},{"location":"Quantum%20Error%20Correction/#quantum","title":"Quantum","text":""},{"location":"Quantum%20Error%20Correction/#caveats","title":"Caveats","text":"<p>Redundancy can not work in the quantum case due to the No-Cloning Theorem. Also we can't directly measure quantum states to find out about the errors that occurred. This leads to a collapse of the wave function.</p> <p>$\\alpha | 0 \\rangle + \\beta | 1 \\rangle \\rightarrow | 0 \\rangle \\; \\text{or}\\;  | 1 \\rangle$, information about $\\alpha$ and $\\beta$ lost ($M_z$). even worse for entangled states $\\alpha | 000 \\rangle + \\beta | 111 \\rangle \\rightarrow | 000 \\rangle \\; \\text{or}\\;  | 111 \\rangle$ by measuring one of the qubits only ($M_{z_1}$). $\\Rightarrow$ Measuring a single qubit collapses the state!</p>"},{"location":"Quantum%20Error%20Correction/#error-types","title":"Error types","text":"Error type Example Error operator Bit flip $|0\\rangle\\rightarrow|1\\rangle$ X Phase flip $\\alpha | 0 \\rangle+ \\beta | 1 \\rangle\\rightarrow\\alpha | 0 \\rangle- \\beta | 1 \\rangle$ Z Bit+Phase flip $\\alpha | 0 \\rangle+ \\beta | 1 \\rangle\\rightarrow\\alpha | 1 \\rangle- \\beta | 0 \\rangle$ Y Errors in quantum information are intrinsically continuous (rather than discrete): Example: Undesired perturbation Hamiltonian $H \\propto X$ $U(t)= \\exp(-iHt)=e^{-i\\phi X}=\\cos \\phi \\mathbb{I} - i \\sin \\phi X$ $\\Rightarrow U(t) \\psi\\rangle=\\cos \\phi \\psi\\rangle - i \\sin \\phi X $\\Rightarrow p_e = \\sin^2 \\phi, 1-p_{e} = \\cos^2 \\phi$ <p>The effective error model we use in the following are stochastic, independently distributed (uncorrelated) X,Y,Z errors with probability $p$.</p>"},{"location":"Quantum%20Error%20Correction/#codes","title":"Codes","text":"<p>By constructing [logical qubits]] a quantum repetition code can be constructed such as the [3-qubit code. The code can detect $d-1$ errors and correct $(d-1)/2$ errors.</p>"},{"location":"Quantum%20Error%20Correction/#stabilizer-formalism","title":"Stabilizer formalism","text":"<p>Stabilizer states are a set of commuting observables which allow to describe a large class of multi-qubit states including all QEC codes considered here. Example: Bell states are stabilizer states, e.g.: $|\\Phi^+\\rangle=\\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)$ Stabilizers $S_1=Z_1Z_2$ and $S_2=X_1X_2$ $|\\Phi^+\\rangle$ is a unique 2-qubit state $|\\psi\\rangle$ for which $S_1 |\\psi\\rangle=+|\\psi\\rangle, \\quad S_2 |\\psi\\rangle=+|\\psi\\rangle$ All stabilizers commute $[S_i,S_k]=0$ and span a $2^{n}$ dimensional Abelian group. The Stabilizer state is uniquely fixed to $|\\psi\\rangle$ by imposing $S_i|\\psi\\rangle=+|\\psi\\rangle$ for $i=1,\u2026,n$. The stabilizers span the n-dimensional subspace which is called the codespace. Also logical operators $Z_L$ and $X_L$ can be defined which fulfill the following: $Z_L|0\\rangle_L=|0\\rangle_L$ $Z_L|1\\rangle_L=-|1\\rangle_L$ $X_L|0\\rangle_L=|1\\rangle_L$ $X_L|1\\rangle_L=|0\\rangle_L$ Logical operators need to commute with the stabilizers, $[O_L,S_i]=0$, and mutually anticommute, ${X_L,Z_L}=0$. Essentially one counts the number of anticommutes ${X_i,Z_i}=0$ and if its even, hen it commutes otherwise it anticommutes.</p> <ul> <li>A distance-$d$ QEC code can correct $\\lfloor{\\frac{d-1}{2}}\\rfloor$ errors.</li> <li>A distance-$d$ QEC code can detect $d-1$ errors.</li> <li>There exist weight-$d$ errors that directly induce an (undetectable) logical error Generally QEC doesn\u2018t account for every single qubit error which is bound by the Quantum Hamming Bound</li> </ul>"},{"location":"Quantum%20Error%20Correction/#improvements","title":"Improvements","text":"<p>These codes can concatenated, the advantage is that the failure probability of logical qubits gets exponentially suppressed as the system size increases. Assuming the gate error probability is $p&lt;1/3$ the failure probability for the $L$'th layer is $p_\\text{fail}= \\frac{1}{3}(3p)^{2^L}$. One example of such concatenation of the 3-qubit code is the [9-qubit Shor code]]. Other than that larger codes have a higher success probability. For an n-code with [[distance]] $d$ which is the minimal [[weight]] the error probability scales with $p_\\text{fail}\\approx\\binom{n}{(d-1)/2}p^{(d+1)/2}$ for small $p$. The [Quantum Threshold Theorem assumes that every component can fail and guarantees an error probability where arbitrary quantum computations can be performed efficiently. In practice the error threshold are very demanding ($10^{-5}\u202610^{-6}$).</p>"},{"location":"Quantum%20Error%20Correction/#topological-qec-codes","title":"Topological QEC codes","text":"<p>Idea: -  topology = robust global features which are invariant under local changes or perturbations - assumption: noise and errors act locally - Store quantum information spread out globally to protect it against noise The error thresholds are about $10^{-2}\u202610^{-3}$ and fault tolerant QC might be possible in practice! To what topological QEC codes are can be seen in . Examples are the [Kitaev\u2018s toric code]] and the [[Surface Code]]. The smallest 2D topological color code is the [Steane Code</p>"},{"location":"Quantum%20Hamming%20Bound/","title":"Quantum Hamming Bound","text":"<p>How large must a Hilbert space be, so that one can accommodate a QEC code that fulfills the following conditions? - n qubits, $k$ encoded qubits, error correction works for up to $t$ errors. Reasoning: For $j \\leq t$ errors, there are $\\binom{n}{j}$ possible locations, 3 types of errors ($X,Y,Z$), thus a total number of possible errors $\\sum_{j=0}^t\\binom{n}{j}3^j$ The code space is $2^k$-dimensional and each error is required to map the codespace to an $2^k$-dim. Orthogonal subspace. All these subspace need to fit in the $2^n$-dim. Hilbert space:</p> <p>$$ \\sum_{j=0}^t\\binom{n}{j}3^j\\cdot2^k \\leq 2^n $$</p> <p>For 1 logical qubit ($k=1$), 1 arbitrary correctable error (distance $d=3$) ($t=1$), this particularizes to: $2(1+3n)\\leq 2^n$ $\\Rightarrow n \\geq 5$ qubits needed for smallest complete code, with stabilizers and logical operators ($S_i$ are cyclic permuations) $S_1=X_1Z_2Z_3X_4\\mathbb{I}_5$ $S_2=\\mathbb{I}_1X_2Z_3Z_4X_5$ $S_3=X_1\\mathbb{I}_2X_3Z_4Z_5$ $S_4=Z_1X_2\\mathbb{I}_3X_4Z_5$ $Z_L=Z_1Z_2Z_3Z_4Z_5$ $X_L=X_1X_2X_3X_4X_5$</p>"},{"location":"Quantum%20Threshold%20Theorem/","title":"Quantum Threshold Theorem","text":"<p>There exists a physical error probability $p_c$ below which arbitrary and a bunch of ancilla qubits quantum computations can be performed efficiently.</p>"},{"location":"Steane%20Code/","title":"Steane Code","text":"<p>The Steane Code is a $7,1,1$ complete code.</p>"},{"location":"Steane%20Code/#publish-me","title":"publish-me","text":""},{"location":"Surface%20Code/","title":"Surface Code","text":"<ul> <li>Planar (2D) lattice structures are suitable for practical realizations of topological Quantum Error Correction|QER codes.</li> <li>Planar surface code hosting one logical qubit: No periodic boundary conditions! </li> </ul>"},{"location":"Surface%20Code/#characteristics","title":"Characteristics","text":"<ul> <li>Logical $X_L$ ($Z_L$) operators need to start over opposite smooth (rough) boundaries of the lattice respectively.</li> <li>Thus these are non-contractible strings starting and ending at boundaries (topological property)</li> <li>They fulfill the anticommutation relation ${X_L^{(1)},Z_L^{(1)}}=0$ and commute with all stabilizers.</li> <li>4-qubit plaquette and vector stabilizers in the bulk</li> <li>Reduced 3-qubit $X$-type and $Z$-type stabilizers at the smooth and rough boundaries</li> </ul> <p>Minimal surface codes of distance $d=3$ (one arbitrary error correctable):</p> <p> - 9 data qubits encoding one logical qubit - Often displayed Together with 8 Ancilla qubits for the measurement of the 8 stabilizers: </p> <ul> <li>One of the currently pursued codes for first generation of logical qubits (e.g. IBM, Google, academic groups)</li> </ul>"},{"location":"Surface%20Code/#toric-vs-planar-codes","title":"Toric vs. planar codes","text":""},{"location":"distance/","title":"Distance","text":"<p>The code distance $d$ is the smallest weight i.e. the number of physical qubits that a logical operator has support on.</p> <ul> <li>A distance-$d$ QEC code can correct $\\lfloor{\\frac{d-1}{2}}\\rfloor$ errors.</li> <li>A distance-$d$ QEC code can detect $d-1$ errors.</li> <li>There exist weight-$d$ errors that directly induce an (undetectable) logical error</li> </ul>"},{"location":"indirect%20measurement/","title":"Indirect measurement","text":"<p>An indirect measurement can be achieved by the following construction: Consider a unitary (n-qubit)operator $U$ with eigenvalues $\\pm 1$.  $$ \\begin{align} U \\lvert 0 \\rangle \\lvert \\psi \\rangle &amp;= \\lvert 0 \\rangle \\lvert \\psi \\rangle \\quad \\text{(no error)} \\ U \\lvert 0 \\rangle \\lvert \\psi \\rangle &amp;= -\\lvert 0 \\rangle \\lvert \\psi \\rangle \\quad \\text{(error)} \\ \\lvert 0 \\rangle \\lvert \\psi \\rangle &amp;\\xrightarrow{H} \\frac{1}{\\sqrt{2}}(\\lvert 0 \\rangle + \\lvert 1 \\rangle)\\lvert \\psi \\rangle \\ &amp;\\xrightarrow{\\text{CU}} \\frac{1}{\\sqrt{2}}(\\lvert 0 \\rangle\\lvert \\psi \\rangle + \\lvert 1 \\rangle U\\lvert \\psi \\rangle) \\ &amp;\\xrightarrow{H} \\frac{1}{2}[(\\lvert 0 \\rangle + \\lvert 1 \\rangle)\\lvert \\psi \\rangle + (\\lvert 0 \\rangle - \\lvert 1 \\rangle)U\\lvert \\psi \\rangle] \\ &amp;= |0\\rangle\\frac{1}{2}(\\mathbb{I}+U)\\lvert \\psi \\rangle + |1\\rangle\\frac{1}{2}(\\mathbb{I}-U)\\lvert \\psi \\rangle \\ &amp;=|0\\rangle P_+ |\\psi\\rangle+|1\\rangle P_- |\\psi\\rangle \\end{align}</p> <p>$$ $P_\\pm= \\frac{1}{2}(1\\pm U)$ are projection operators on the $\\pm1$ eigenspaces of $U$ $\\rightarrow$ Realizes a measurement of $U$ The projectors share a common eigenbasis with U by construction and commute. The states of the codespace span the $P_+$ subspace and thus always the $|0\\rangle$-state is measured with certainty. The elements outside the codespace (errors) span the $P_-$ subspace and thus always the $|1\\rangle$-state is measured.</p>"},{"location":"indirect%20measurement/#example","title":"Example","text":"<p>In the 3-qubit code for unitary $U=Z_1Z_2$ the following circuit can be used to do an indirect measurement: </p>"},{"location":"Algorithms/Deutsch-Josza/","title":"Deutsch Josza","text":"<p>The Deutsch-Josza Algorithm is the multifunction generalization of the Deutsch Algorithm.</p>"},{"location":"Algorithms/Deutsch-Josza/#problem","title":"Problem","text":"<ul> <li>For N=$2^n$, we are given an N-bit String $x \\in {0,1}^N$ as input such that either:</li> <li>all $x_i$ have the same value (\u201cconstant\u201c) </li> <li>N/2 of the $x_i$ are 0, and $N/2$ are 1 (\u201cbalanced\u201c)</li> <li>Here the index $i \\in {0,1}^N$ from $i=0$ to $2^n-1$, to label all $N=2^N$ elements.</li> <li>We can view this again as a function $x_i=f(i)$</li> <li>Goal: find out whether x is constant or balanced<ul> <li>Note: We are not interested in the individual values $x_i$, but only in the global property whether x is constant or balanced</li> </ul> </li> </ul>"},{"location":"Algorithms/Deutsch-Josza/#example","title":"Example","text":"<p>N=8, n=3 $x=(11111111); x$ constant $x = (10010101); x$ balanced</p>"},{"location":"Algorithms/Deutsch-Josza/#classical-computation","title":"Classical Computation","text":"<ul> <li>First compute individual values $x_0,x_1,x_2,\u2026,x_{N-1}$<ul> <li>In this step we obtain more information than we need, namely on the individual values</li> </ul> </li> <li>In a second step, we compare the values- $\\Rightarrow$ A classical algorithm requires in general $\\frac{N}{2} + 1$ evaluations of x to answer the question (Worst case, if $x_{N/2+1}$ is the same as all before we know for certainty that the function is constant. With less evaluations we can only guess)</li> </ul>"},{"location":"Algorithms/Deutsch-Josza/#quantum-computation","title":"Quantum Computation","text":"<ul> <li>Claim: we can do better, with a single evaluation of f. We won\u2018t (in fact must not) obtain any information on the individual values $x_i=f(i)$, if we will be able to answer the question</li> </ul>"},{"location":"Algorithms/Deutsch-Josza/#the-query-setting","title":"The query setting","text":"<ul> <li>Many quantum algorithms work with queries (including [Grover]] and [Shor)</li> <li>We can think of the inputs as an N-bit memory, which we can access at any point of our choice (RAM)</li> <li>A memory access is via a so-called \u201eblack-box\u201c, which outputs bit $x_i$ on input $i$</li> <li>As a quantum operation, this is realized by the (n+1)-qubit unitary $O_x: | i,b \\rangle \\rightarrow |i, b \\oplus x_i \\rangle$, with address register of n qubits $i \\in {0,1}^n$ target bit $b \\in {0,1}$</li> <li>Remarks:<ul> <li>After the transformation, the state $|i, b \\oplus x_i \\rangle$ is not necessarily a product state ($|i, b \\oplus x_i \\rangle \\neq |i \\rangle | b \\oplus x_i \\rangle$) , unless $|i \\rangle$ is one compuational basis state</li> <li>$O_x$ is unitary and hermitian because $O_x^2=\\mathbb{I}$ </li> <li>Every application of $O_x$ requires one evaluation of $x$</li> </ul> </li> </ul>"},{"location":"Algorithms/Deutsch-Josza/#implementation","title":"Implementation","text":"<ul> <li>We want to prepare an equal-weight superposition off all basis states on the first n qubits with Hadamard-Gate|H-Gates </li> <li>If $|b \\rangle = |0 \\rangle$ then we get<ul> <li>$O_x \\frac{1}{\\sqrt{2^n}} \\sum_{i \\in {0,1}^n} |i \\rangle | 0 \\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{i \\in {0,1}^n} |i \\rangle | x_i \\rangle =  \\frac{1}{\\sqrt{2^n}} ( | 0 \\rangle |x_0 \\rangle + | 1 \\rangle |x_1 \\rangle + \u2026 + | N-1 \\rangle |x_{N-1} \\rangle)$</li> <li>The state contains all function values in superposition in the target qubit, and (in general) entangled with the first n qubits</li> <li>But we can access the information: If we measure the first qubits, the superposition collapses with probability $1/2^n$ to any computational state $|i \\rangle |x_i \\rangle$. This is not better than one evaluation in a classical algorithm. Similar to [Deutsch]] we need [Algorithmic Interference here.</li> </ul> </li> <li>If $|b \\rangle = |- \\rangle$ then we get<ul> <li>$O_x |i \\rangle |- \\rangle = (-1)^{x_i} |i \\rangle | - \\rangle$ (see Deutsch)</li> <li>So the action of the phase Oracle is $|i \\rangle \\rightarrow (-1)^{x_i} | i \\rangle$ which does nothing if $x_i=0$ and adds a phase if $x_i=1$, the oracle can be thus noted as $O_{x,\\pm}$</li> </ul> </li> <li>Now we reapply Hadamard-Gate|H-Gates and get the following in total: $$ \\begin{align} H^{\\otimes n}O_{x,\\pm} \\frac{1}{\\sqrt{2^n}} \\sum_{i \\in {0,1}^n} |i \\rangle &amp;= H^{\\otimes n}\\frac{1}{\\sqrt{2^n}} \\sum_{i \\in {0,1}^n} (-1)^{x_i}|i \\rangle \\ &amp;=\\frac{1}{2^n} \\sum_{i \\in {0,1}^n} (-1)^{x_i} \\sum_{j \\in {0,1}^n} (-1)^{i \\cdot j} | j \\rangle \\ \\end{align} $$ For $x$ is constant, our state is $|0\\rangle^{\\otimes n}$ if all $x_i=0$ and $-|0\\rangle^{\\otimes n}$ if  all $x_i=1$ because this is the only $|j \\rangle$ that survives. So if we measure this state we know for certainty that we have a constant function. If we measure a different state we know for certainty that we have a balanced function. We have again a global phase which is inaccessible which is important!</li> </ul>"},{"location":"Algorithms/Deutsch-Josza/#comparison","title":"Comparison","text":"<ul> <li>The Deutsch-Josza algorithm can be solved with certainty using only one quantum query and $O(n)$ other operations</li> <li>In contrast any classical deterministic algorithm needs at least N/2 +1 queries<ul> <li>Classical algorithm can solve this problem efficiently if we allow for a small error probability and can be in general better if we allow this</li> </ul> </li> </ul>"},{"location":"Algorithms/Deutsch-Josza/#bernstein-vazirani-algorithm","title":"Bernstein-Vazirani Algorithm","text":"<ul> <li>It is identical to the Deutsch-Josza algorithm but with the additional property $x_i= (i \\cdot a) \\mod{2}$, the final measurement yields a with certainty</li> <li>Per definition of the Hadamard-Gate|H-Gates the following holds:<ul> <li>$H^{\\otimes n} |a \\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{i \\in {0,1}^n} (-1)^{a \\cdot i} |i \\rangle$</li> </ul> </li> <li>After step (3) we have (with inserting $x_i$)<ul> <li>$H^{\\otimes n}\\frac{1}{\\sqrt{2^n}} \\sum_{i \\in {0,1}^n} (-1)^{x_i}|i \\rangle = H^{\\otimes n}\\frac{1}{\\sqrt{2^n}} \\sum_{i \\in {0,1}^n} (-1)^{i \\cdot a}|i \\rangle = H^{\\otimes n} H^{\\otimes n} |a \\rangle = |a \\rangle$ </li> </ul> </li> </ul>"},{"location":"Algorithms/Deutsch-Josza/#algorithm-steps-summary","title":"Algorithm steps summary","text":"<ol> <li>Start with an $|0 \\rangle^{\\otimes n}$ register</li> <li>Apply a Hadamard to end the qubit</li> <li>Apply a phase oracle query $O_{x,\\pm}$ </li> <li>Apply another Hadamard to each qubit</li> <li>Measure the final state</li> </ol>"},{"location":"Algorithms/Deutsch-Josza/#circuit-implementation","title":"Circuit implementation","text":""},{"location":"Algorithms/Deutsch/","title":"Deutsch","text":"<p>The Deutsch Algorithm was developed by David Deutsch (1992). This was the first algorithm that showed the potential computational power of quantum computation. The Algorithm demonstrates typical features and ingredients of quantum computation for example [Quantum Superposition]] and [Quantum Entanglement.</p>"},{"location":"Algorithms/Deutsch/#setting","title":"Setting","text":"<ul> <li>Consider a single bit $x= {0,1}$</li> <li>A black box that computes a function $f(x)$</li> <li>We do not know (and do not care) how, but every evaluation of f is extremely costly (e. g. in terms of computational time)     $\\Rightarrow$ Thus, we want to limit the number of evaluations of f to an absolute minimum</li> </ul>"},{"location":"Algorithms/Deutsch/#possible-outcomes","title":"Possible outcomes","text":"<p>$f(0)=0;1$  $f(1)=0;1$ $\\Rightarrow$ 4 possibilities So there are two cases: $f(0)=f(1)$: f is constant, all bits are the same. or $f(0) \\neq f(1)$: f is balanced, half of the bits are 0, the other half 1.</p> <p>We are not interested in the individual values of $f(0)$ and $f(1)$ but only in the global property whether f is constant or balanced.</p>"},{"location":"Algorithms/Deutsch/#classical-computation","title":"Classical Computation","text":"<ul> <li>First compute individual values $f(0)$ and $f(1)$. We get more information than we need, namely on the individual values.</li> <li>In a second step we compare the two values $\\Rightarrow$ We need two evaluations</li> </ul>"},{"location":"Algorithms/Deutsch/#quantum-computation","title":"Quantum Computation","text":"<ul> <li>Claim: We can do better, with a single evaluation of f. We won\u2018t (in fact must not) obtain any information on the individual values of f, yet we will be able to answer the question</li> <li>We will use two qubits,<ul> <li>$|x \\rangle = \\alpha_x | 0 \\rangle + \\beta_x | 1 \\rangle$</li> <li>$|y\\rangle = \\alpha_y | 0 \\rangle + \\beta_y | 1 \\rangle$</li> </ul> </li> <li>in an initial product state<ul> <li>$|x,y \\rangle = | x \\rangle | y \\rangle$</li> </ul> </li> <li>We will use a two-qubit unitary transformation<ul> <li>$U_f: | x \\rangle | y \\rangle \\rightarrow |x,y \\oplus f(x) \\rangle$</li> <li>Here $\\oplus$ denotes addition modulo 2</li> </ul> </li> <li>The transformation leaves the first qubit unchanged and acts on the second one as follows:<ul> <li>If $f(x)=0$ y is not changed</li> <li>If $f(x)=1$ y is flipped $0 \\rightarrow 1; 1 \\rightarrow 0$</li> </ul> </li> <li>Remarks:<ul> <li>After the transformation, the state $|x, y \\oplus f(x) \\rangle$ can not be written as a product state: $|x, y \\oplus f(x) \\rangle \\neq |x \\rangle | y \\oplus f(x) \\rangle$</li> <li>$U_f$ is unitary and Hermitian because $U_f^2= \\mathbb{I}$</li> <li>Every application of $U_f$ requires one evaluation of f</li> </ul> </li> <li>For $|+ \\rangle |0 \\rangle$ we get:<ul> <li>$U_f |+ \\rangle |0\\rangle = U_f \\frac{1}{\\sqrt{2}} (|0 \\rangle |0\\rangle + |1 \\rangle |0\\rangle) = \\frac{1}{\\sqrt{2}} (|0 \\rangle |f(0)\\rangle + |1 \\rangle |f(1)\\rangle)$</li> <li>This state contains both functions in superposition in the second qubit and in general entangled with the first qubit</li> <li>If we measure the first qubit the second qubit collapses to either $|f(0) \\rangle$ or $|f(1) \\rangle$ with probability 1/2. This is not better than one evaluation in a classical algorithm because we get to know the both individual values (with uncertainty). It is even worse. $\\Rightarrow$ [Quantum Parallelism]] is an ingredient for speedup but not enough. We also need [Algorithmic Interference, i. e. a way of constructively interfering the paths such that the information we are interested in (f balanced or constant) is amplified, and the information we don\u2018t care about (individual values $f(0)$ and $f(1)$) becomes inaccessible.</li> </ul> </li> <li>If we prepare the $|-\\rangle$-state we get the following:<ul> <li>$U_f |x \\rangle |-\\rangle = |x\\rangle \\frac{1}{\\sqrt{2}}(|0 \\oplus f(x) \\rangle - |1 \\oplus f(x) \\rangle) = (-1)^{f(x)} |x \\rangle |-\\rangle$   </li> </ul> </li> <li>For $|+ \\rangle |- \\rangle$ we get:<ul> <li>$U_f |+ \\rangle |-\\rangle = U_f \\frac{1}{\\sqrt{2}} (|0 \\rangle |-\\rangle + |1 \\rangle |-\\rangle) = \\frac{1}{\\sqrt{2}} ((-1)^{f(0)}|0 \\rangle |-\\rangle + (-1)^{f(1)}|1 \\rangle |-\\rangle)$  </li> </ul> </li> </ul> $f(0)$ $f(1)$ $U_f |+ \\rangle |-\\rangle$ 0 0 $|+ \\rangle |-\\rangle$ 1 0 $-|- \\rangle |-\\rangle$ 0 1 $|- \\rangle |-\\rangle$ 1 1 $-|+ \\rangle |-\\rangle$ - So the first qubit is measured as $ + \\rangle$ for a constant function and $ - \\rangle$ for a balanced function - The information of the individual function values appear as a global phase factor ($\\pm 1$) which can not be measured directly. - Final Step: $X_1$ measurement $\\rightarrow$ the probability of the $ + \\rangle$-state is 1 for f constant $\\rightarrow$ the probability of the $ - \\rangle$-state is 1 for f balanced <ul> <li>With specific preparation of  and an Oracle which is an implementation of $f(x)$ </li> <li>Remarks:<ul> <li>We evaluated f only once</li> <li>Speedup due to Quantum Parallelism is 2 (Constant)</li> </ul> </li> </ul>"},{"location":"Algorithms/Deutsch/#circuit-implementation","title":"Circuit implementation","text":""},{"location":"Algorithms/Grover/","title":"Grover","text":"<p>The quantum search algorithm was proposed by Lev Grover in 1994.</p>"},{"location":"Algorithms/Grover/#the-problem","title":"The problem","text":"<ul> <li>Search through a search space of N elements.</li> <li>Assume for convenience $N=2^n$ $\\rightarrow$ n bits of information to label one element</li> <li>Assume that the problem of interest has exactly $M &lt;N$ solutions (typically $M \\ll N$) $\\Rightarrow$ How fast can we find at least one of the solutions? A particular instance of a problem is conveniently represented by a function $f$, which takes as an input an integer $x$, $0 \\leq x \\leq N-1$, and yields     $f(x)=1$ if $x$ is a solution to the search problem     $f(x)=0$ if $x$ is not a solution to the search problem</li> </ul>"},{"location":"Algorithms/Grover/#example","title":"Example","text":"<p>Hamiltonian path problem: A particular graph $G$ specifies $f$. Inputs $x$ correspond to paths (i.e. sequences of vertices)     $$ f(x) = \\begin{cases} 1 &amp; \\text{if } x \\text{ is a Hamiltonian path in } G \\ 0 &amp; \\text{otherwise} \\end{cases} $$ </p> <p>Note: One doesn\u2018t need to know a Hamiltonian path beforehand, to be able to recognize one!</p>"},{"location":"Algorithms/Grover/#the-quantum-algorithm","title":"The Quantum Algorithm","text":""},{"location":"Algorithms/Grover/#oracle","title":"Oracle","text":"<ul> <li>Unitary operator $O_f$:     $O_f | x,q \\rangle = | x, q \\oplus f(x) \\rangle$     Where $x$ is the input state of n qubits and $q$ the single oracle qubit (see Deutsch-Josza)</li> <li>For $|q\\rangle = |- \\rangle$ this realizes the phase oracle i the usual way:     $|x \\rangle | - \\rangle = (-1)^{f(x)} |x \\rangle | - \\rangle$ $\\Rightarrow O_{f,\\pm}|x\\rangle = \\begin{cases} - | x \\rangle &amp; \\text{if } x \\text{ is a solution } \\ | x \\rangle &amp; \\text{otherwise} \\end{cases}$</li> <li>The implementation of the oracle depends on the solutions!</li> <li>Discussion:<ul> <li>The oracle does not know any of the solution(s), it is only able to recognize a solution</li> <li>The exact construction of the oracle is not important</li> <li>It can however be constructed using e. g. known classical (efficient) algorithms, which are simply \u201erun on a quantum computer\u201c. Checking solutions is in P for any problem in NP It is always possible to implement (with a polynomial overhead of [Ancilla|Ancillas]] and circuit depth) a solution checking subroutine (see [Deutsch-Josza a solution checking subroutine (see [[Deutsch-Josza.md)) Examples:</li> </ul> </li> <li>a solution checking whether a path x is Hamiltonian</li> <li>A subroutine checking whether an integer $p$ is a prime factor of the larger number $N$, e. g. by simple division: $q=N/p$ integer?</li> </ul>"},{"location":"Algorithms/Grover/#grovers-algorithm","title":"Grover\u2018s algorithm","text":"<ol> <li>Prepare initial state $| \\psi \\rangle = \\frac{1}{\\sqrt{2^N}} \\sum_x | x \\rangle$ (unbiased superposition)</li> <li>Perform the Grover iteration $k$ times:<ul> <li>apply oracle $O_{f,\\pm}$</li> <li>Then apply \u201ereflection operator\u201c $U=2|\\psi \\rangle \\langle \\psi | - \\mathbb{I}$</li> </ul> </li> <li>Measure the qubits, yielding an outcome $x$</li> </ol>"},{"location":"Algorithms/Grover/#circuit-implementation","title":"Circuit implementation","text":""},{"location":"Algorithms/Grover/#functionality","title":"Functionality","text":"<p>Rewrite the initial state</p> <p>$$</p> <p>\\begin{align} | \\Psi \\rangle &amp;= \\frac{1}{\\sqrt{N}} \\sum_x | x\\rangle = \\frac{1}{\\sqrt{N}} \\left(\\sum^{\u2019\u2019} |x \\rangle + \\sum^{\u2019} |x \\rangle \\right) \\ &amp;= \\frac{1}{\\sqrt{N}} \\left(\\sqrt{N-M} \\frac{1}{\\sqrt{N-M}} \\sum^{\u2019\u2019} |x \\rangle + \\sqrt{M} \\frac{1}{\\sqrt{M}} \\sum^{\u2019} |x \\rangle \\right) \\ &amp;= \\sqrt{\\frac{N-M}{N}} | \\alpha \\rangle + \\sqrt{\\frac{M}{N}} | \\beta \\rangle \\ &amp;= \\sqrt{1-\\varepsilon} | \\alpha \\rangle + \\sqrt{\\varepsilon} | \\beta \\rangle \\end{align} $$ With $\\sum^{\u2019\u2019}$ being the sum over all states which are not solutions, $\\sum^{\u2019}$ being the sum over all states which are solutions and $\\varepsilon = \\frac{M}{n}$ typically $\\varepsilon \\ll 1$ (solutions are hard to find) - Probability to find (measure) a particular solution $|x \\rangle$ in $| \\psi \\rangle: \\frac{1}{N}$  - Probability to find any solution. Projector onto solution subspace $\\hat{P}= \\sum^{\u2019}|x \\rangle \\langle x | \\rightarrow p = \\langle \\psi | \\hat{P} | \\psi \\rangle = \\frac{M}{N}=\\varepsilon$ The oracle unitary $O$ can be written as     $O= 1-2 \\sum^{\u2019} |x \\rangle \\langle x |$     Let\u2018s apply one Grover step $G=UO$ to $| \\psi \\rangle$: $$ \\begin{align} O | \\psi \\rangle &amp;= O(\\sqrt{1-\\varepsilon} | \\alpha \\rangle + \\sqrt{\\varepsilon} | \\beta \\rangle) \\ &amp;= \\sqrt{1-\\varepsilon} | \\alpha \\rangle - \\sqrt{\\varepsilon} | \\beta \\rangle \\ &amp;= (\\sqrt{1-\\varepsilon} | \\alpha \\rangle + \\sqrt{\\varepsilon} | \\beta \\rangle)- 2\\sqrt{\\varepsilon} | \\beta \\rangle \\ &amp;= |\\psi \\rangle - 2 \\sqrt{\\varepsilon} | \\beta \\rangle \\ UO |\\psi \\rangle &amp;= (2 |\\psi \\rangle \\langle \\psi | - \\mathbb{I})(|\\psi \\rangle - 2 \\sqrt{\\varepsilon} | \\beta \\rangle) \\ &amp;= 2  |\\psi \\rangle - |\\psi \\rangle - 4 \\sqrt{\\varepsilon} \\langle \\psi|\\beta\\rangle |\\psi \\rangle + 2\\sqrt{\\varepsilon} |\\beta \\rangle \\ &amp;= (1-4 \\varepsilon)|\\psi \\rangle+2\\sqrt{\\varepsilon} | \\beta \\rangle \\ &amp;= (1-4\\varepsilon) (\\sqrt{1-\\varepsilon} | \\alpha \\rangle + \\sqrt{\\varepsilon} | \\beta \\rangle)+2\\sqrt{\\varepsilon} | \\beta \\rangle \\ &amp;= (1-4 \\varepsilon) \\sqrt{1-\\varepsilon} |\\alpha \\rangle + \\sqrt{\\varepsilon}(3-4 \\varepsilon)|\\beta \\rangle \\end{align} $$ Now, the probability to find the system in any solution sate measuring $UO\\psi\\rangle$ is     $p=(\\sqrt\\varepsilon(3-4\\varepsilon))^2=9 \\varepsilon=9\\frac{M}{N}$, the probability has increased by a factor of 9!</p>"},{"location":"Algorithms/Grover/#geometric-visualization","title":"Geometric Visualization","text":"<ul> <li>Dynamics takes place only in a 2-dimensional subspace spanned by $|\\alpha\\rangle$ and $|\\beta\\rangle$ $|\\psi \\rangle=\\cos\\frac{\\theta}{2} |\\alpha \\rangle + \\sin \\frac{\\theta}{2} |\\beta \\rangle$     Parameterization with $\\cos\\frac{\\theta}{2}=\\sqrt{\\frac{N-M}{N}}=\\sqrt{1-\\varepsilon}$ and $\\sin\\frac{\\theta}{2}=\\sqrt{\\frac{M}{N}}=\\sqrt{\\varepsilon}$  </li> </ul> <p>$\\rightarrow$ State is rotated towards $|\\psi \\rangle$ (the solutions):     $G|\\psi \\rangle = \\cos{\\frac{3\\theta}{2}} |\\alpha \\rangle + \\sin{\\frac{3\\theta}{2}} |\\beta \\rangle$     $G^k|\\psi \\rangle = \\cos{\\frac{2k+1}{2} \\theta} |\\alpha \\rangle + \\sin{\\frac{2k+1}{2} \\theta} |\\beta \\rangle$ How many times $k$ should $G$ be applied? $\\sin{\\frac{2k+1}{2}\\theta} \\approx 1$ $\\frac{2k+1}{2}\\theta \\approx \\frac{\\pi}{2} \\rightarrow k \\approx \\frac{\\pi}{2\\theta}$ $\\sin\\frac{\\theta}{2} \\approx \\frac{\\pi}{2} = \\sqrt{\\frac{M}{N}}$ $\\rightarrow \\tilde{k} \\approx \\frac{\\pi}{4}\\sqrt{\\frac{N}{M}}$ are optimal</p> <p>[!IMPORTANT] $O(\\sqrt{\\frac{N}{M}})$ oracle queries suffice to find a solution with probability close to 1</p> <p>Compare to classical case $O(\\frac{N}{M})$ $\\rightarrow$ Quadratic Speeedup</p>"},{"location":"Algorithms/Grover/#discussion","title":"Discussion","text":"<p>The Grover algorithm can be used to speed up NP-complete problems. Example: Hamiltonian Path problem Brute Force search $n^n=2^{n \\cdot \\log(n)}$ Paths Quantum speed-up: reduction to $O(2^{n\\cdot\\log(n)/2})$</p>"},{"location":"Algorithms/Grover/#optimality","title":"Optimality","text":"<p>One can prove that there exists no quantum algorithm that can perform he task with less than $O\\left(\\sqrt{\\frac{N}{M}}\\right)$ oracle inquiries. This, the Grover algorithm is optimal</p> <p>If we choose the integer $k$ closest to $\\tilde{k}$, the failure probability will still be small: $$ \\begin{align} p_\\mathrm{fail} &amp;= \\cos\\left({\\frac{2k+1}{2}\\theta}\\right)^2 \\ &amp;= \\cos\\left({\\frac{2\\tilde{k}+1}{2}\\theta} + (k-\\tilde{k}) \\theta \\right)^2 \\ &amp;= \\cos\\left(\\frac{\\pi}{2} + (k-\\tilde{k}) \\theta \\right)^2 \\ &amp;= \\sin\\left((k-\\tilde{k}) \\theta \\right)^2 \\ &amp;\\leq \\sin\\left(\\frac{\\theta}{2}\\right)^2 \\mathrm{for} \\, |k-\\tilde{k}| \\leq \\frac{1}{2}, \\mathrm{and} \\, \\theta \\ll 1 \\ &amp;= \\frac{M}{N} \\; \\mathrm{small} \\end{align} $$</p> <p>Number of queries: $k \\leq \\frac{\\pi}{2 \\theta} \\leq \\frac{\\pi}{4}\\sqrt{\\frac{N}{M}}$ $\\Rightarrow$ Number of queries does not grow.</p>"},{"location":"Algorithms/Grover/#problems","title":"Problems","text":"<ul> <li>If we don\u2018t know $M$, we don\u2018t know how many steps $k$ t apply - if $k$ get\u2018s too big, the success probability decreases again</li> <li>Assumption of knowing beforehand the number $M$ of solutions can be relaxed: A slightly more complicated algorithm (basically running the above algorithm with systematic different for $k$) still finds a solution with an expected number of queries $O\\left(\\sqrt{\\frac{N}{M}}\\right)$</li> <li>The algorithm can also be modified o estimate the number of solutions: Quantum Counting</li> </ul>"},{"location":"Algorithms/Oracle/","title":"Oracle","text":"<p>The oracle does nothing with the state if it is the solution. If it is the solution it adds a Phase (for example -1). An oracle is a black box whose internal working are not important, the oracle has the ability to recognize the problem</p>"},{"location":"Algorithms/Quantum%20Fourier%20Transform/","title":"Quantum Fourier Transform","text":""},{"location":"Algorithms/Quantum%20Fourier%20Transform/#classical-discrete-fourier-transform","title":"Classical Discrete Fourier Transform","text":"<ul> <li>Input: length-N vector of complex numbers $x_0,x_1,\u2026,x_{N-1}$</li> <li>Output: transformed data $y_0,y_1,\u2026,y_{N-1}$ Definition of FT: $$ \\begin{align} y_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1}x_j e^{2\\pi i j k/N} &amp;= \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1}\\omega_N^{jk}x_j \\ &amp;\\omega_N = e^{2\\pi/N} \\leftarrow \\text{N-th root of unity} \\end{align} $$</li> </ul> <p>Inverse FT (using Kronecker Delta identity): $$ \\begin{align} x_l &amp;= \\frac{1}{\\sqrt{N}} \\sum_{n=0}^{N-1}y_ne^{-2 \\pi i n l/N} = \\frac{1}{\\sqrt{N}} \\sum_{n=0}^{N-1} y_n \\left(\\omega_N^{jk}\\right)^ \\ &amp;= \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{j=0}^{N-1} x_je^{2\\pi in(j-l)/N} \\ &amp;= \\frac{1}{N} \\sum_{j=0}^{N-1}x_j N \\delta_{jl} = x_l \\end{align*} $$ Example: For $N=2$: $\\omega_2=e^{2 \\pi i /2}=-1$ $\\Rightarrow F_2=H=\\frac{1}{\\sqrt{2}} \\begin{pmatrix}\\omega_2^{0\\cdot0} &amp; \\omega_2^{0\\cdot1} \\ \\omega_2^{1\\cdot0} &amp; \\omega_2^{1\\cdot1}\\end{pmatrix}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 &amp; 1 \\ 1 &amp; -1\\end{pmatrix}$ For arbitrary $N$: Unitary $N \\times N$ matrix:</p> <p>$$</p> <p>\\mathcal{F}_N = \\frac{1}{\\sqrt{N}} \\left( \\begin{array}{ccccc} \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ \\cdots &amp; &amp; \\omega_N^{jk} &amp; &amp; \\cdots \\ &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots \\end{array} \\right) $$</p> <p>Costs: - Naively: $O(N)$ steps (multiplication and addition) per entry, thus $O(N^2)$ for length-N vector - More efficient: Fast Fourier Transform (FFT), takes. Only $O(N\\log N)$ steps.</p>"},{"location":"Algorithms/Quantum%20Fourier%20Transform/#quantum-fourier-transform-qft","title":"Quantum Fourier Transform (QFT)","text":"<p>QFT acts on orthonormal basis states $|0\\rangle,|1\\rangle,\u2026,|N-1\\rangle$: $$ |j\\rangle \\rightarrow \\frac{1}{\\sqrt{N}} \\sum_{k=0}^{N-1}e^{2\\pi i j k/N}|k \\rangle $$</p> <p>Thus, the action on an arbitrary input state</p> <p>$$ \\begin{align} \\sum_{j=0}^{N-1}x_j |j\\rangle &amp;\\rightarrow \\sum_{j=0}^{N-1}x_j \\frac{1}{\\sqrt{N}} \\sum_{k=0}^{N-1}e^{2\\pi i j k/N}|k \\rangle \\ &amp;= \\sum_{k=0}^{N-1} \\left(\\frac{1}{\\sqrt{N}}\\sum_{j=0}^{N-1}x_j e^{2\\pi i j k/N} \\right)|k \\rangle \\ &amp;= \\sum_{k=0}^{N-1} y_k |k\\rangle \\end{align} $$ In the following we will consider $N=2^n$, with $n \\in N$ $|0\\rangle,|1\\rangle,\u2026,|2^n-1\\rangle$ are computational basis states of n qubits. A state $|j\\rangle$ can be written in binary representation as $j=j_1j2\u2026j_n$, which stands for $$ j=j_12^{N-1}+j_22^{N-2} + \u2026 + j_{n-1}2^1+j_n2^0 $$ E.g.: $n=3,N=2^3=8$: $|5\\rangle=|1\\rangle|0\\rangle|1\\rangle$</p> <p>We will also use the binary fraction notation</p> <p>$0.j_lj_{l+1}\u2026j_m=j_l/2 + j_{l+1}/4 + \u2026 + j_m/2^{m-l+1}$</p> <p>Useful Identity: $$ \\begin{align} \\frac{k}{2^n} &amp;= \\frac{k_12^{n-1}+k_22^{n-2}+\u2026+k_n2^0}{2^n} \\ &amp;= k_12^{-1}+k_22^{-2}+\u2026+k_n2^{-n} \\ &amp;= \\sum_{l=1}^nk_l 2^{-l} \\end{align} $$ The action of the QFT on a ground state is the following:</p> <p>$$ \\begin{align} &amp;|j\\rangle=|j_1\\rangle|j_2\\rangle\u2026|j_n\\rangle \\ &amp;|j\\rangle \\rightarrow\\frac{1}{\\sqrt{2^n}}\\sum_{k=0}^{2^n-1}e^{2 \\pi i j k/2^n}|k\\rangle \\ &amp;= \\frac{1}{\\sqrt{2^n}} \\sum_{k=0}^{2^n-1}e^{2 \\pi i j \\left(\\sum_{l=1}^nk_l 2^{-l}\\right)}|k_1\\rangle|k_2\\rangle\u2026|k_n\\rangle \\ &amp;= \\frac{1}{\\sqrt{2^n}} \\sum_{k_1=0}^{1}\\sum_{k_2=0}^{1}\u2026\\sum_{k_n=0}^{1}e^{2 \\pi i j \\left(\\sum_{l=1}^nk_l 2^{-l}\\right)}|k_1\\rangle|k_2\\rangle\u2026|k_n\\rangle \\ &amp;= \\frac{1}{\\sqrt{2^n}} \\bigotimes_{l=1}^n \\left[\\sum_{k_l=0}^1 e^{2 \\pi i j k_l 2^{-l}} |k_l\\rangle\\right] \\ &amp;= \\bigotimes_{l=1}^n \\frac{1}{\\sqrt{2}} \\left(|0\\rangle + e^{2 \\pi i j/2^l} |1\\rangle\\right) \\ &amp;= \\bigotimes_{l=1}^n |\\tilde{k}l\\rangle \\ &amp;= |\\tilde{k}_1\\rangle \\otimes |\\tilde{k}_2\\rangle \\otimes \u2026 \\otimes |\\tilde{k}_n\\rangle\\ &amp;= \\frac{1}{\\sqrt{2}} \\left(|0\\rangle + e^{2 \\pi i 0.j_n} |1\\rangle\\right) \\otimes \\frac{1}{\\sqrt{2}} \\left(|0\\rangle + e^{2 \\pi i 0.j{n-1}j_n} |1\\rangle\\right) \\otimes \u2026 \\otimes \\frac{1}{\\sqrt{2}} \\left(|0\\rangle + e^{2 \\pi i 0.j_1j_2\u2026j_{n}} |1\\rangle\\right) \\end{align} $$ This is a product state, no entanglement is created. In the exponential $\\exp\\left({2 \\pi i \\frac{j}{2^l}}\\right)$ not all terms are important, as integer multiples of $2 \\pi i$ will lead simply to a factor of 1: $$ \\begin{align} \\rightarrow \\exp\\left({2 \\pi i \\frac{j}{2^l}}\\right) &amp;= \\exp\\left(2 \\pi i [\\frac{1}{2}j_{n-l+1}+\\frac{1}{2^2}j_{n-l+2}+\u2026+\\frac{1}{2^l}j_n]\\right) \\ &amp;=\\sum_{m=0}^{l-1}\\frac{1}{2^{l-m}}j_{n-m} \\  &amp;=0.j_{n-l+1}j_{n-l+2}\u2026j_n \\end{align} $$ Only the last $l$ binary digits of $j$ matter. $R_k$ can be generated by a Rz gate up to a global phase: $R_k=e^{\\pi i/2^k} R_z(2 \\pi/2^k)$. </p> <p>$R_k=\\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; e^{2 \\pi i/2^k} \\end{pmatrix}$</p> <p>Example: $n=3$</p> <p>$l=1: e^{2 \\pi i 0.j_3}=e^{2 \\pi i \\frac{1}{2}j_3} = \\begin{cases} 1 &amp; \\text{if } j_3 = 0 \\ -1 &amp; \\text{if } j_3=1 \\end{cases}$   </p> <p>$l=2: e^{2 \\pi i 0.j_2j_3}=e^{2 \\pi i \\left(\\frac{1}{2}j_2 + \\frac{1}{4}j_3\\right)}$ (first part Hadamard, second part is a phase drift $R_2$ on qubit 2, depending on $j_3$)  $l=2: e^{2 \\pi i 0.j_1j_2j_3}=e^{2 \\pi i \\left(\\frac{1}{2}j_1 + \\frac{1}{4}j_2+\\frac{1}{8}j_3\\right)}$ (first part Hadamard, second part $R_2$ depending on $j_2$, third part $R_3$ depending on $j_3$) </p>"},{"location":"Algorithms/Quantum%20Fourier%20Transform/#circuit-implementation-n3","title":"Circuit Implementation (n=3)","text":"<p>The SWAP Gate at the end ensures that the qubit order is consistent. Those are not necessary though.</p>"},{"location":"Algorithms/Quantum%20Fourier%20Transform/#circuit-implementation","title":"Circuit Implementation","text":"<p>Resources: - $n$ Hadamard-Gate|Hadamard-Gates $O(n)$ - $n(n-1)/2$ conditional rotations $O(n^2)$ (2 CNOT gate|CNOTs each) - At most $n/2$ swap gates (3 CNOTs each) $\\Rightarrow O(n^2)$ Quantum Algorithm Comparison: Best classical algorithm FFT requires $O(n2^n)$ gates. $\\Rightarrow$ QFT provides an exponential speedup Note: The QFT is not an algorithm to speed up the computation of classical Fourier transforms. Problem: - No way known to access the amplitudes in a quantum computer directly - No way now to efficiently prepare original state to be transformed But: QFT is a key ingredient in other quantum algorithms like Quantum Phase Estimation.</p>"},{"location":"Algorithms/Quantum%20Order%20Finding/","title":"Quantum Order Finding","text":""},{"location":"Algorithms/Quantum%20Order%20Finding/#order-finding","title":"Order finding","text":"<ul> <li>The problem of order finding is equivalent to factoring</li> <li>We will develop an efficient quantum algorithm for order finding hoch in turn provides an efficient way to factor</li> <li>The quantum algorithm for order finding will be using Quantum Phase Estimation For positive integers $x$ and $N$, $x&lt;N$, with no common factors (i.e. $x$ and $N$ are coprime) the order of $x$ modulo $N$ is defined to be the smallest integer $r$, such that  $$ x^r=1 \\mod N $$ Example: $x=3, N=7$</li> </ul> <p>$$ \\begin{align} x^1 \\mod N = 3^1 \\mod 7 = 3 \\ x^2 \\mod N = 3^2 \\mod 7 = 2 \\ x^3 \\mod N = 3^3 \\mod 7 = 6 \\ x^4 \\mod N = 3^4 \\mod 7 = 4 \\ x^5 \\mod N = 3^5 \\mod 7 = 5 \\ x^6 \\mod N = 3^6 \\mod 7 = 1 \\ \\end{align} $$ $\\rightarrow$ order of 3 modulo 7 is $r=6$ This is then cyclic, if we continue: $x^7 \\mod N = 3$ Since $x^{r+i} \\mod N = (x^rx^i) \\mod N=(x^r \\mod N)(x^i \\mod N) \\mod N= x^i \\mod N$</p> <p>[!IMPORTANT] Order finding is believed (not proven!) To be a hard problem on a classical computer</p> <p>No algorithm is known to solve the problem using resources that are polynomial in the $O(L)$ bits needed to specify the problem, where $L=\\lceil \\log N \\rceil$is the number of bits needed to specify $N$. In essence, the quantum algorithm for order finding is the quantum phase estimation algorithm applied to the unitary $U |y\\rangle\\equiv|xy\\mod N\\rangle$, where $|y\\rangle$ is an $L$-qubit state, $y \\in {0,1}^L$ Not that we are using the convention that when $N \\leq y \\leq 2^L-1$ the expression $xy \\mod N=y$. In other words, $U$ acts non-trivially only when $0 \\leq y \\leq N-1$. The following states $|u_s\\rangle\\equiv \\frac{1}{\\sqrt{r}} \\sum_{k=0}^{r-1} \\exp\\left(-\\frac{2 \\pi i s k}{r}\\right) |x^k \\mod N\\rangle$ are eigenstates of $U$ as shown below: $$ \\begin{align} U|u_s\\rangle &amp;= \\frac{1}{\\sqrt{r}} \\sum_{k=0}^{r-1} \\exp\\left(-\\frac{2 \\pi i s k}{r}\\right) U|x^k \\mod N\\rangle \\ &amp;= \\frac{1}{\\sqrt{r}} \\sum_{k=0}^{r-1} \\exp\\left(-\\frac{2 \\pi i s k}{r}\\right) |x^{k+1} \\mod N\\rangle \\ &amp;= \\frac{1}{\\sqrt{r}} \\sum_{k\u2019=1}^{r} \\exp\\left(-\\frac{2 \\pi i s (k\u2019-1)}{r}\\right) |x^{k\u2019+1} \\mod N\\rangle \\ &amp;=\\exp\\left(\\frac{2 \\pi i s}{r}\\right)\\frac{1}{\\sqrt{r}} \\sum_{k\u2019=0}^{r-1} \\exp\\left(-\\frac{2 \\pi i s k\u2019}{r}\\right) |x^{k\u2019+1} \\mod N\\rangle \\ &amp;=\\exp\\left(\\frac{2 \\pi i s}{r}\\right)|u_s\\rangle \\end{align} $$ We used $k\u2019=k+1$ and the fact that the $k\u2019=r$ term is the same as the $k\u2019=0$ term which allows us to shift the sum. Using phase estimation will allow is it obtain with high accuracy the corresponding eigenvalues $\\exp\\left(-\\frac{2 \\pi i s}{r}\\right)$ from which we will be able to obtain the order $r$ with some extra work. Problem: Preperation of $|u_s\\rangle$ would require knowledge about $r$ so this is impossible. However we don\u2018t need this since the superposition of all eigenstates (using the Kronecker Delta identity): $$ \\begin{align} \\frac{1}{\\sqrt{r}}\\sum_{s=0}^{r-1} |u_s\\rangle &amp;= \\frac{1}{r}\\sum_{s=0}^{r-1}\\sum_{k=0}^{r-1} \\exp\\left(-\\frac{2 \\pi i s k}{r}\\right) |x^k \\mod N\\rangle \\ &amp;= \\frac{1}{r}\\sum_{k=0}^{r-1} r \\delta_{k0} |x^k \\mod N\\rangle \\ &amp;= |x^0 \\mod N\\rangle \\ &amp;= |1\\rangle = |0\\rangle|0\\rangle\u2026|0\\rangle|1\\rangle \\end{align} $$</p>"},{"location":"Algorithms/Quantum%20Order%20Finding/#modular-exponentiation","title":"Modular exponentiation","text":"<p>For each $s$ in the range 0 to $r-1$ this will lead an estimate of the phase $\\varphi \\approx \\frac{s}{r}$ that is accurate to $2L+1$ bits, and with probability at least $(1-\\varepsilon)/r$.</p> <p>For the algorithm to be efficient, we need efficient procedures to implement controlled $U^{2^j}$-operations. This can be achieved by a technique called modular exponentiation.</p> <p>We need to realize the transformation $$ \\begin{align} |z\\rangle | y \\rangle &amp;\\rightarrow |z\\rangle U^{z_t 2 ^{t-1}}\u2026U^{z_1 2 ^{0}} |y\\rangle \\ &amp;= |z\\rangle |x^{z_t2^{t-1}} \\times \u2026 \\times x^{z_12^{0} y \\mod N} \\ &amp;= |z\\rangle|x^zy \\mod N \\rangle \\end{align} $$ This can be achieved using reversible computing using temporarily a third register. For that we compute $x^{2^j} \\mod N$ by squaring $x^{2^j-1} \\mod N$ up to $x^{2^t-1}$. $\\rightarrow$ Since $t=2L+1 + \\left\\lceil \\log{\\left(2+\\frac{1}{2 \\varepsilon}\\right)}\\right\\rceil$ These are $O(L)$ squaring operations. Each requires $O(L^2)$ operations (standard multiplication). $\\rightarrow$ $O(L^3)$ operations which can be translated into a reversible quantum circuit with $O(L^3)$ quantum gates which realizes $|z\\rangle = |z\\rangle|x^zy \\mod N \\rangle$</p>"},{"location":"Algorithms/Quantum%20Order%20Finding/#continued-fractions-algorithm","title":"Continued Fractions Algorithm","text":"<p>The last step to get $r$ is using the Continued Fractions Algorithm whose use is allowed to the following theorem: For a rational number $\\frac{s}{r}$ such that $\\left|\\frac{s}{r}-\\varphi\\right| \\leq \\frac{1}{2r^2}$ then $s/r$ is a convergent of the continued fractions for $\\varphi$, and thus can be calculated in $O(L^3)$ steps. Since $\\varphi$ is accurate to $2L+1$ bits it follows $\\left|\\frac{s}{r}-\\varphi\\right| \\leq \\frac{1}{2^{2L+1}} \\leq \\frac{1}{2r^2}$ since $r \\leq N \\leq 2^L$. Thus this theorem applies.</p>"},{"location":"Algorithms/Quantum%20Order%20Finding/#functionality","title":"Functionality","text":"<p>Since $P \\in N=2$. Thus the theorem applies.</p> <p>Express real numbers by integers</p> <p>$[a_0, a_1, ..., a_M] = a_0 + \\cfrac{1}{a_1 + \\cfrac{1}{a_2 + \\cfrac{1}{... + \\cfrac{1}{a_M}}}}$</p>"},{"location":"Algorithms/Quantum%20Order%20Finding/#example","title":"Example","text":"<p>Imagine that $S=5$ and $r=6$ such that $\\varphi = \\frac{5}{6}= 0.833...$</p> <p>Imagine we have measured the outcome $\\tilde{\\varphi} = 0. \\varphi_1 \\varphi_2 \\varphi_3 \\varphi_4 \\varphi_5 = 0.110101$ meaning $\\tilde{\\varphi} = 1 \\cdot \\frac{1}{2} + 1 \\cdot \\frac{1}{4} + 0 \\cdot \\frac{1}{8} + 1 \\cdot \\frac{1}{16} + 0 \\cdot \\frac{1}{32} + 1 \\cdot \\frac{1}{64} = \\frac{53}{64}$</p> <p>Write $\\frac{53}{64}$ as a continued fraction:</p> <p>$\\frac{53}{64} = 0 + \\frac{1}{\\frac{64}{53}} = 0 + \\frac{1}{1 + \\frac{11}{53}}$</p> <p>$= 0 + \\frac{1}{1 + \\frac{1}{\\frac{53}{11}}} = 0 + \\frac{1}{1 + \\frac{1}{4 + \\frac{9}{11}}}$</p> <p>$= 0 + \\frac{1}{1 + \\frac{1}{4 + \\frac{1}{1 + \\frac{2}{9}}}}$</p> <p>$= 0 + \\frac{1}{1 + \\frac{1}{4 + \\frac{1}{1 + \\frac{1}{4 + \\frac{1}{2}}}}}$</p> <p>$\\implies [a_0, ..., a_5] = [0, 1, 4, 1, 4, 2]$</p> <p>Continued fraction algorithm requires $O(L^3)$ steps.</p> <p>If we stop after 1 step: $\\frac{1}{1} \\leftarrow$ not $r$ \" 2 steps: $\\cfrac{1}{1 + \\cfrac{1}{4}} = \\frac{4}{5} \\leftarrow$ not $r$ \" 3 steps: $\\cfrac{1}{1 + \\cfrac{1}{4 + \\cfrac{1}{1}}} = \\frac{5}{6} \\leftarrow$ found $r!$ $\\checkmark$</p> <p>The algorithm provides efficiently numbers $\\frac{s'}{r'}$. The denominator $r'$ is our candidate for the order $r$. We can check whether $r'$ is the order by calculating $x^{r'} \\pmod{N}$, and if this is $=1$, we have found $r$. Checking solutions in NP are always efficient.</p>"},{"location":"Algorithms/Quantum%20Order%20Finding/#costs","title":"Costs","text":"<ul> <li>Hadamard-Gate|Hadamard-gates: $O(L)$ gates</li> <li>Inverse Quantum Fourier Transform|FT: $O(L^2)$ gates</li> <li>Modular exponentiation: $O(L^3)$ gates</li> <li>Classical continued fraction algorithm: $O(L^3)$ gates</li> <li>Without proof: f the order finding attempt fails, one only needs to repeat a constant number of times to obtain the order r with high probability $\\Rightarrow$ Overall cost $O(L^3)$, this can be reduced to almost $O(L^2)$ by using known algorithms for fast integer multiplications modulo $N$</li> </ul>"},{"location":"Algorithms/Quantum%20Order%20Finding/#the-quantum-algorithm","title":"The quantum algorithm","text":"<ul> <li>Inputs:<ul> <li>Blackbox $U$ which performs $|j\\rangle|k\\rangle \\rightarrow |j\\rangle|x^jk \\mod N \\rangle$ for x being a coprime to the $L$-bit number $N$ to be factored</li> <li>Use $t=2L+1 + \\left\\lceil \\log{\\left(2+\\frac{1}{2 \\varepsilon}\\right)}\\right\\rceil$ qubits for the first register, prepared all in $|0\\rangle$</li> <li>Prepare $L$ qubits the second register in the $|1\\rangle$ state</li> </ul> </li> <li>Outputs:<ul> <li>The order $r$, i.e. the smallest integer $r$ for which $x^r=1 \\mod N$</li> </ul> </li> <li>Runtime:<ul> <li>$O(L^3)$ operations. Succeeds with probability $O(1)$</li> </ul> </li> <li>Steps:<ol> <li>$|0\\rangle|1\\rangle$<ul> <li>initial state of $t$ and $L$ qubits</li> </ul> </li> <li>$\\rightarrow \\frac{1}{\\sqrt{2^t}}\\sum_{j=0}^{2^t-1} |j\\rangle |1\\rangle$<ul> <li>superposition through Hadamards</li> </ul> </li> <li>$\\rightarrow \\frac{1}{\\sqrt{2^t}}\\sum_{j=0}^{2^t-1} |j\\rangle |x^j \\mod N\\rangle$     $\\approx \\frac{1}{\\sqrt{r2^t}} \\sum_{s=0}^{r-1} \\sum_{j=0}^{2^t-1} \\exp\\left(\\frac{2 \\pi i s}{r}\\right)|j\\rangle |u_s\\rangle$  <ul> <li>apply $U$ operations</li> </ul> </li> <li>$\\rightarrow \\frac{1}{\\sqrt{r}} \\sum_{s=0}^{r-1} |\\tilde{s/r}\\rangle |u_s\\rangle$<ul> <li>apply inverse Quantum Fourier Transform|FT to 1st register</li> </ul> </li> <li>$\\rightarrow \\tilde{\\varphi}=\\tilde{s/r}$<ul> <li>measure 1st register</li> </ul> </li> <li>$\\rightarrow r$<ul> <li>apply continued fraction algorithm</li> </ul> </li> </ol> </li> </ul>"},{"location":"Algorithms/Quantum%20Order%20Finding/#circuit-implementation","title":"Circuit Implementation","text":""},{"location":"Algorithms/Quantum%20Order%20Finding/#next-step","title":"Next step","text":"<p>Factoring can be reduced to Order finding which is the most important ingredient in Shor\u2018s algorithm</p>"},{"location":"Algorithms/Quantum%20Phase%20Estimation/","title":"Quantum Phase Estimation","text":"<p>This makes use of Quantum Fourier Transform|QFT.</p>"},{"location":"Algorithms/Quantum%20Phase%20Estimation/#setting","title":"Setting","text":"<p>Suppose that a unitary $U$ has an eigenvector $|u \\rangle$ with eigenvalue $e^{2 \\pi \\varphi}$, where $\\varphi$ is unknown. The goal is to estimate $\\varphi$ (Note that $0 \\le \\varphi &lt; 1$). Assumptions: We have black boxes that prepare $| u \\rangle$ and peform controlled-$U^{2^j}$ operations, for suitable non-negative integers $j$</p>"},{"location":"Algorithms/Quantum%20Phase%20Estimation/#the-algorithm","title":"The algorithm","text":""},{"location":"Algorithms/Quantum%20Phase%20Estimation/#functionality","title":"Functionality","text":"<ul> <li>We will have two qubit registers:<ul> <li>The first register contains $t$ qubits intitially in $|0\\rangle$</li> <li>The choice of $t$ will depend on<ul> <li>The desired number of digits of accuracy of the estimate of $\\varphi$</li> <li>The desired success probability with which we wish the phase estimation procedure to be successful</li> </ul> </li> <li>The second register begins in $|u\\rangle$, containing as many qubits as are necessary to store $|u\\rangle$</li> </ul> </li> <li>First we create an unbiased superposition by putting Hadamard-Gate|H-Gates for all $t$ qubits for the first register. Then we do $n$ controlled-$U^{2^j}$ operations on the second register which is controlled by the $j$th qubit on the first register. Consider one qubit of the first register, and $|u\\rangle$     $$     \\begin{align}     |0\\rangle | u \\rangle &amp;\\xrightarrow{H}\\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)|u\\rangle \\     &amp;\\xrightarrow{C-U^{2^j}} \\frac{1}{\\sqrt{2}}(|0\\rangle|u\\rangle + |1\\rangle U^{2^j} |u\\rangle \\     &amp;= \\frac{1}{\\sqrt{2}}\\left(|0\\rangle + e^{2 \\pi i \\left(2^j \\varphi\\right)} |1\\rangle\\right)|u\\rangle \\     \\rightarrow \\text{Output states:} \\     &amp;\\frac{1}{\\sqrt{2^t}} \\sum_{k=0}^{2^t-1} e^{2 \\pi i \\varphi k} |k\\rangle |u\\rangle\\     &amp;=\\frac{1}{\\sqrt{2^t}}\\left(|0\\rangle + e^{2 \\pi i 0.\\varphi_t} |1\\rangle\\right)\\left(|0\\rangle + e^{2 \\pi i 0.\\varphi_{t-1}\\varphi_{t}} |1\\rangle\\right)\\left(|0\\rangle + e^{2 \\pi i 0.\\varphi_{t_1}\u2026\\varphi_{t}} |1\\rangle\\right) |u\\rangle \\     &amp;\\xrightarrow{\\text{FT}^\\dagger} |\\varphi \\rangle|u\\rangle = |\\varphi_1\\rangle |\\varphi_2\\rangle\u2026|\\varphi_t\\rangle |u\\rangle     \\end{align}     $$ All computational basis states are encoded in binary representation $|k\\rangle$. Example: so the output state for t=4 k=3 is $\\frac{1}{4}|0\\rangle|0\\rangle e^{2 \\pi i \\left(2^1 \\varphi\\right)}|1\\rangle e^{2 \\pi i \\left(2^0 \\varphi\\right)}|1\\rangle=\\frac{1}{4}|0\\rangle|0\\rangle|1\\rangle|1\\rangle e^{2 \\pi i \\varphi\\cdot3}=\\frac{1}{4}|3\\rangle e^{2 \\pi i \\varphi\\cdot3}$. The measurement of the qubits on the first register provides us $\\varphi$ exactly.</li> </ul>"},{"location":"Algorithms/Quantum%20Phase%20Estimation/#algorithm-steps-summary","title":"Algorithm steps summary","text":"<ol> <li>Hadamard gates on all qubits of register 1</li> <li>Controlled-$U$ operations on the second register, with $U$ raised to successive power of 2, controlled by the qubits of the first register</li> <li>Apply the inverse QFT </li> <li>Measure the qubits of the first register in the computational basis</li> </ol>"},{"location":"Algorithms/Quantum%20Phase%20Estimation/#circuit-implementation","title":"Circuit implementation","text":""},{"location":"Algorithms/Quantum%20Phase%20Estimation/#discussion-of-performance-and-requirements","title":"Discussion of performance and requirements","text":"<ul> <li>In general $\\varphi$ can\u2018t be written exactly as binary $t$-bit expansion</li> <li>One can show that if one wants to get an approximate estimate for $\\varphi$ to an accuracy $2^{-n}$, and one wants the probability to obtain an estimate of this precision to be at least $1-\\varepsilon$, one needs to choose the number of qubits in the first register as  $$  t= n + \\left[\\log{\\left(1+\\frac{1}{2 \\varepsilon}\\right)}\\right] $$ $\\Rightarrow$ This is a small additional increase only (linear in $n$) What if we can\u2018t prepare $|u\\rangle$? Let\u2019s start in some other state $|\\psi\\rangle$ instead, which can be written as $|\\psi\\rangle=\\sum_u c_u |u\\rangle$ with eigenstates $|u\\rangle$ of $U$, with eigenvalues $e^{2 \\pi \\varphi_u}$. The output of the quantum phase approximation circuit will be $\\sum_u c_u |\\tilde{\\varphi}_u \\rangle |u \\rangle$, where  $\\tilde{\\varphi}_u$ is a good approximation to the eigenvalue $\\varphi_u$. Measurement of the first register will then yield with probability $|c_u|^2$ the approximate value $\\tilde{\\varphi}_u$. $\\Rightarrow$ We can avoid preparing $|u\\rangle$ at the expense of introducing some additional randomness into the algorithm</li> </ul>"},{"location":"Algorithms/Quantum%20Phase%20Estimation/#iterative-quantum-phase-estimation","title":"Iterative Quantum Phase Estimation","text":"<p>It is also possible to estimate the phase in an iterative process. First the following circuit with controlled $U_{n-j}$ by the ancillas is being applied with a measurement in the X Gate|X-basis, for qubits 2,\u2026,n additional unitaries controlled by the $(j-1)$th classical bit given by the X-measurement $R_{j}^{\\dagger}R_{j-1}^{\\dagger}\u2026R_2^{\\dagger}$ are added before the measurement.</p>"},{"location":"Algorithms/Quantum%20Phase%20Estimation/#circuit-implementation_1","title":"Circuit Implementation","text":""},{"location":"Algorithms/Shor%E2%80%98s%20algorithm/","title":"Shor\u2018s algorithm","text":""},{"location":"Algorithms/Shor%E2%80%98s%20algorithm/#problem","title":"Problem","text":"<ul> <li>The problem of factoring: Given a positive composite integer number $N$, what are the prime factors multiplied together equaling $N$?</li> <li>A fast algorithm for order finding can be converted into a fast algorithm for factoring</li> <li>Factoring is believed to be hard on classical computers: For an $L$-bit integer $N$, the best classical algorithms known to date (number field sieve) require roughly $\\exp(O(L^{1/3}))$ operations. This is exponential in the number of bits describing the number $N$</li> </ul>"},{"location":"Algorithms/Shor%E2%80%98s%20algorithm/#reduction","title":"Reduction","text":"<p>We can find a factor of $N$ if we find a non-trivial solution of $y^2= 1 \\mod N$. There are always two trivial solutions: $y=1$ and $y=-1 \\equiv (N-1) \\mod N$ However if N is divisible by two distinct odd primes, these are at least two more non-trivial square roots in $\\mathbb{Z}^_N$ (i.e. among the set of numbers between 1 and $N-1$, which are coprime with N): $$ \\begin{align} &amp;y^2-1= (y+1)(y-1)= 0 \\mod N \\ &amp;\\rightarrow (y+1)(y-1)= k \\cdot N \\quad \\text{for some k} \\end{align} $$ If $y \\neq \\pm 1 \\mod N$, then neither $y+1$ nor $y-1$ is a multiple of $N$. $\\Rightarrow$ In that case, the greatest common divisors $\\gcd(y+1,N)$ and $\\gcd(y-1,N)$ must each be proper divisors of $N$, i.e. prime factors we are looking for. How can we find a non-trivial square root $y$? $\\Rightarrow$ Choose a random integer $x$, $1 &lt; x \\leq N-1$, check whether $x$ is coprime of $N$. If it\u2018s not coprime, $N$ and $x$ share a prime factor, which we can easily find and we are done. If $x$ is coprime $x$ of $N$, then run the Quantum Order Finding algorithm to find $r$: $$ \\begin{align} &amp; \\quad \\quad x^r= 1 \\mod N \\ &amp;\\Leftrightarrow (x^{r/2})^2 = 1 \\mod N\\ &amp;\\Leftrightarrow (x^{r/2}+1)(x^{r/2}-1) = 0 \\mod N\\ &amp;\\Leftrightarrow (x^{r/2}+1)(x^{r/2}-1) = k \\cdot N \\quad \\text{for some k} \\end{align} $$ In other words if we are lucky and the order $r$ is even, then $y=x^{r/2}$ is a square root of 1. We know for sure that $x^{r/2} \\neq 1 \\mod N$, since $r$ is the smallest integer for which this is true. If we are again lucky and $x^{r/2} \\neq -1 \\mod N$ too, then $x^{r/2}$ is a non-trivial* root. We then can calculate $\\gcd(x^{r/2}+1,N)$ and $\\gcd(x^{r/2}-1,N)$ to find non-trivial prime factors. Calculating gcd is efficient (Euclid\u2018s algorithm).</p>"},{"location":"Algorithms/Shor%E2%80%98s%20algorithm/#example","title":"Example","text":"<p>$N=21$ Choose e.g. $x=2$ $\\Rightarrow x^6=64 \\mod 21=1$ $\\Rightarrow$ order $r=6$ Check: $x^{r/2}=2^3 = 8 \\neq -1 \\mod 21$ $\\Rightarrow$ 8 is a non-trivial square root of 1 in $\\mathbb{Z}^*_{21}$. $\\Rightarrow \\gcd(9,21)=3$ and $\\gcd(7,21)=7$</p>"},{"location":"Algorithms/Shor%E2%80%98s%20algorithm/#success-probability","title":"Success Probability","text":"<p>The number of elements of good coprimes where their order $r$ is even and $x^{r/2} \\neq -1 \\mod N$ can be determined in the following:</p>"},{"location":"Algorithms/Shor%E2%80%98s%20algorithm/#theorem-without-proof","title":"Theorem (without proof)","text":"<p>If $N$ us divisible by $l$ distinct odd primes, then at least a fraction $1-\\frac{1}{2^{l-1}}$ of the elements in $\\mathbb{Z}^*_N$ are good. $\\Rightarrow$ Thus, for $l\\geq2$, the probability to pick a good coprime $x$ is at least $1/2$. $\\Rightarrow$ We need only $O(1)$ trials.</p>"},{"location":"Algorithms/Shor%E2%80%98s%20algorithm/#resource-discussion","title":"Resource Discussion","text":"<p>Shor\u2018s quantum algorithm for factoring requires $O(1)$ runs of the quantum algorithm for order finding. $\\Rightarrow$ Overall $O(L^3)$ runtime $\\Rightarrow$ Compared to classical runtime $\\exp(O(L^{1/3}))$  $\\Rightarrow$ Exponential speedup</p>"},{"location":"Gates/Classical%20Logic%20Gates/","title":"Classical Logic Gates","text":"<ul> <li>Idealized or physical electronic devices that realize a Boolean function: a logical operation performed on one or more binary inputs ($0/1 \\mathrel{\\widehat{=}}$ FALSE/TRUE) that produce a single binary output</li> </ul>"},{"location":"Gates/Classical%20Logic%20Gates/#examples","title":"Examples","text":""},{"location":"Gates/Classical%20Logic%20Gates/#universality","title":"Universality","text":"<p>There exists a minimal set of gates to implement any classical Boolean circuit. The set of gates are not unique, one example is {AND, NOT}. An example of a single gate that is universal is the NAND gate.</p>"},{"location":"Gates/Classical%20Logic%20Gates/#irreversible-computation","title":"Irreversible Computation","text":"<p>The classical two-bit gates are essentially irreversible and non-invertible: for example from the output $a \\oplus b$ of the XOR gate, it is impossible to determine what the inputs a and b were. $\\Rightarrow$ There is an irretrievable loss of information associated with the irreversible action of the XOR-gate, and other classical two-bit logic gates</p>"},{"location":"Gates/Classical%20Logic%20Gates/#reversible-computation","title":"Reversible Computation","text":"<p>The Toffoli Gate is reversible.</p>"},{"location":"Gates/Clifford%20Gates/","title":"Clifford Gates","text":"<ul> <li>All Pauli Gates are Clifford Gates and the Generator of the Clifford Group: $\\sigma_0= \\mathbb{I}, \\sigma_1=X, \\sigma_2=Y, \\sigma_3=Z$ </li> <li>For n qubits one can construct the Pauli group:     $P_n= {e^{i \\frac{\\pi}{2} \\cdot k } \\cdot \\sigma_{j_1} \\otimes \u2026 \\otimes \\sigma_{j_n} | k=0,1,2,3 \\; \\mathrm{and} \\; j_k=0,1,2,3}$     $e^{i\\frac{i \\pi \\cdot k}{2}} \\in {1,i,-1,-i}$</li> <li>The n-qubit Clifford group is defined as the n qubit unitaries $V \\in U_n$ that normalize the Pauli Group:     $C_n={V P_n V^\\dagger=P_n}$ Note that this only applies for the entire set $P_n$, not element-wise. Elements of the Clifford group are called Clifford gates.</li> </ul>"},{"location":"Gates/Clifford%20Gates/#examples","title":"Examples","text":"<ul> <li>$n=1$: Hadamard $H \\in C_1$:<ul> <li>$HXH^\\dagger = Z, HZH^\\dagger = X, HYH^\\dagger = -Y$ $\\Rightarrow$ The 16 Elements of $P_1$ are mapped onto $P_1$</li> </ul> </li> <li>But $T \\notin C_1$:<ul> <li>$TZT^\\dagger = Z$,</li> <li>$TXT^\\dagger = \\frac{1}{\\sqrt{2}}(X+Y)\\notin P_1$ $\\Rightarrow$ $TP_1T^\\dagger \\notin P_1$</li> </ul> </li> <li>$n=2$: $\\mathrm{C}_1\\mathrm{NOT}_2 \\in C_2$:<ul> <li>$(\\mathrm{C}_1\\mathrm{NOT}_2)X_1(\\mathrm{C}_1\\mathrm{NOT}_2) = X_1X_2$ etc. The Clifford Gates can be generated by ${\\mathrm{CNOT},H,S}$ only. The Gottesmann-Knill theorem is an important result for efficiency of classical simulation of Clifford Gates.</li> </ul> </li> </ul> <p>The Clifford Group only reaches a discrete Set of the Bloch Sphere. With the Universal Gate Set every point at the Bloch sphere can be reached.</p> <p>Discussion: - Hadamard and CNOT allow to create entangled states. This kind of entanglement alone does not provide an intrinsic quantum speedup! - Clifford Gates are not an universal gate set - Universal quantum computing requires at least one non-Clifford gate, e.g. the T-gate - Important quantum protocols involving only Clifford operations:     - Quantum teleportation     - Magic state distillation     - Quantum Error Correction with stabilizer codes</p>"},{"location":"Gates/Gates/","title":"Gates","text":"<p>Gates are unitary operations a.k.a. matrices. Thus the direction of the circuit and equation are opposite.</p> <p></p>"},{"location":"Gates/Gottesmann-Knill%20theorem/","title":"Gottesmann Knill theorem","text":"<p>[!IMPORTANT] Quantum circuits of only Clifford Gates can be perfectly simulated efficiently, i. e. in polynomial time, on classical computers.</p> <p>More precisely, circuits involving (i) preparation of qubits in computational basis, (ii) Clifford Gates and (iii) measurements in the computational basis.</p>"},{"location":"Gates/Measurement/","title":"Measurement","text":"<p>Single qubit measurements are a measurement of Z if not specified. Pauli measurements are projections into the eigenstates auf the Pauli Operator. It is also called measurement in the Z-basis or measurements in the computational basis. The qubit wire ends with a measurement, unless a classical trigger is set with a classical bit from the measurement.</p> <p></p>"},{"location":"Gates/Solovay-Kitaev-Theorem/","title":"Solovay Kitaev Theorem","text":"<p>A single-qubit $U$ can be approximated to accuracy $\\varepsilon$ using $O(\\log^2\\frac{1}{\\varepsilon})$ gates from the discrete gate set. This is a poly-logarithmic increase- very slow (in particular not an exponential increase in $1/\\varepsilon$).</p>"},{"location":"Gates/Universality%20of%20Quantum%20Gates/","title":"Universality of Quantum Gates","text":"<p>There exist universal gate sets, from which any quantum circuit on n qubits can be built.</p> <p>[!IMPORTANT] CNOT + arbitrary single-qubit rotations = universal</p> <p>[!IMPORTANT] CNOT + small (finite) set of single qubit gates = universal</p>"},{"location":"Gates/Universality%20of%20Quantum%20Gates/#examples","title":"Examples","text":"<ul> <li>{CNOT, H, T}</li> </ul> <p>They allow one to approximate an arbitrary n-qubit circuit to arbitrary precision</p>"},{"location":"Gates/Universality%20of%20Quantum%20Gates/#constructive-proof","title":"Constructive Proof","text":"<ol> <li>Arbitrary n-qubit gates can be decomposed into products of n-qubit unitary operators that act in a 2-dimensional subspace only. Goal: Decompose n-qubit gate U into product of gates acting only with a unitary V on 2-dim subspace only: (Rest of entries are zero) $$ V_n = \\begin{pmatrix} 1 &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        \\   &amp; \\ddots &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        \\   &amp;        &amp; a      &amp;        &amp;        &amp;        &amp; b      &amp;        &amp;        &amp;        \\   &amp;        &amp;        &amp; 1      &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        \\   &amp;        &amp;        &amp;        &amp; \\ddots &amp;        &amp;        &amp;        &amp;        &amp;        \\   &amp;        &amp;        &amp;        &amp;        &amp; 1      &amp;        &amp;        &amp;        &amp;        \\   &amp;        &amp; c      &amp;        &amp;        &amp;        &amp; d      &amp;        &amp;        &amp;        \\   &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp; 1      &amp;        &amp;        \\   &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp; \\ddots &amp;        \\   &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp; 1      \\ \\end{pmatrix} $$</li> </ol> <p>$V=\\begin{pmatrix}a &amp; b \\ c &amp; d \\end{pmatrix}$ unitary, $V^\\dagger V = \\mathbb{I}$</p> <p>Example d=3 for illustration purposes</p> <p>$U=\\begin{pmatrix}a &amp; d &amp; g \\ b &amp; e &amp; h \\ c &amp; f &amp; i \\end{pmatrix}$, $U^\\dagger U=\\mathbb{I}$</p> <p>We will find two-level unitaries $V_k$ such that $V_3V_2V_1U = \\mathbb{I}$ If we manage, it follows that</p> <p>$U^\\dagger = V_3V_2V_1$ and thus  $U=V_1^\\dagger V_2^\\dagger V_3^\\dagger$</p> <p>If $V_k$ are unitaries so are their inverses $V_k^\\dagger$ .</p> <p>If $b=0$, set $V_1=\\begin{pmatrix}1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \\end{pmatrix}$ If $b=0$, set $V_1=\\begin{pmatrix}\\frac{a^}{\\sqrt{|a|^2+|b|^2}} &amp; \\frac{b^}{\\sqrt{|a|^2+|b|^2}} &amp; 0 \\ \\frac{b}{\\sqrt{|a|^2+|b|^2}} &amp; \\frac{-a}{\\sqrt{|a|^2+|b|^2}} &amp; 0 \\ 0 &amp; 0 &amp; 1 \\end{pmatrix}$</p> <p>Note: for both cases $V_1$ is a valid 2-level unitary ^ Now, one can check that $V_1U=\\begin{pmatrix}a\u2019 &amp; d\u2019 &amp; g\u2019 \\ 0 &amp; e\u2019 &amp; h\u2019 \\ c\u2019 &amp; f\u2019 &amp; i\u2019 \\end{pmatrix}$ With some other entries denoted by prime\u2019. The key property is that now the left middle entry is now zero due to construction</p> <p>Next, we will achieve to set the lower left entry to zero:</p> <p>If $c\u2019=0$, set $V_2=\\begin{pmatrix} a\u2019^ &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \\end{pmatrix}$ If $c\u2019=0$, set $V_2=\\begin{pmatrix}\\frac{a\u2019^}{\\sqrt{|a\u2019|^2+|c\u2019|^2}} &amp; 0 &amp; \\frac{c\u2019^*}{\\sqrt{|a\u2019|^2+|c\u2019|^2}} \\ 0 &amp; 1 &amp; 0 \\ \\frac{c\u2019}{\\sqrt{|a\u2019|^2+|c\u2019|^2}} &amp; 0 &amp; \\frac{-a\u2019}{\\sqrt{|a\u2019|^2+|c\u2019|^2}} \\end{pmatrix}$</p> <p>In either case we will find:</p> <p>$V_2V_1U=\\begin{pmatrix}1 &amp; d\u2019\u2019=0 &amp; g\u2019\u2019=0 \\ 0 &amp; e\u2019\u2019 &amp; h\u2019\u2019 \\ 0 &amp; f\u2019\u2019 &amp; i\u2019\u2019 \\end{pmatrix}$ $V_2V_1U$ is unitary thus $d\u2019\u2019=g\u2019\u2019=0$</p> <p>Finally we set $V_3=\\begin{pmatrix}1 &amp; 0 &amp; 0 \\ 0 &amp; e\u2019\u2019^ &amp; h\u2019\u2019^ \\ 0 &amp; f\u2019\u2019^ &amp; i\u2019\u2019^ \\end{pmatrix}$ For d= $2^n$:</p> <ul> <li>We need to construct in general d-1 two-level matrices $U_1,U_2,\u2026,U_{d-1}$ such that</li> </ul> <p>$$ U_{d-1}U_{d-2}\u2026U_1U = \\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp;  &amp; \u2026  \\0 &amp; &amp; \u2026 &amp; \\ 0 &amp;  &amp; \u2026 &amp;  \\end{pmatrix} $$ - Then d-2 for the second column, etc. - In the end we manage to write the  $d \\times d$ matrix $U$ by some two-level matrices $V_i$,     $U=V_1\u2026V_k$     with $k \\leq (d-1) + (d-2) + \u2026 + 1= \\frac{d(d-1)}{2}$     $\\Rightarrow$ For an n-qubit system it follows that U can be written by at most         $2^{n-1}(2^n-1) \\leq 4^n$         two-level matrices</p> <p>Discussion: - This is inefficient (exponential to n) - For specific unitaries much more efficient decompositions may exist - There exist however matrices which can not be decomposed into less than an exponential number of two-level unitaries - Quantum computation and quantum algorithms are not about arbitrary unitaries, but realizing unitaries with a lot of structure which can be efficiently decomposed</p> <ol> <li>Arbitrary such gates, acting only on two computational basis states in the $d=2^n$-dimensional Hilbert space of n-qubits can be written in terms of [CNOT gate|CNOT gates]] and single-qubit [Rotation Gates. Goal: Implement these $V_k$ two-level unitaries by CNOT gate|CNOT gates and single qubit rotations only: Example 1) $n=3$ $d=2^3=8$ </li> </ol> <p>$$ V_k = \\left( \\begin{array}{cccccccc} 1 &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        \\   &amp;  1     &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        \\   &amp;        &amp; 1      &amp;        &amp;        &amp;        &amp;        &amp;        \\   &amp;        &amp;        &amp; 1      &amp;        &amp;        &amp;        &amp;        \\   &amp;        &amp;        &amp;        &amp; 1      &amp;        &amp;        &amp;        \\   &amp;        &amp;        &amp;        &amp;        &amp; 1      &amp;        &amp;        \\   &amp;        &amp;        &amp;        &amp;        &amp;        &amp; a      &amp; b      \\   &amp;        &amp;        &amp;        &amp;        &amp;        &amp; c      &amp;     d  \\ \\end{array} \\right) \\quad \\begin{array}{c} \\ \\ \\ \\ \\ \\ \\leftarrow |110\\rangle \\ \\leftarrow |111\\rangle \\end{array}</p> <p>$$ $V=\\begin{pmatrix}a &amp; b \\ c &amp; d \\end{pmatrix}$ unitary, $V^\\dagger V = \\mathbb{I}$</p> <p>This acts non-trivially only on $|110 \\rangle$ and $| 111 \\rangle$. This means that V is applied to qubit 3 iff qubit 1 and 2 are in $|1 \\rangle$. This Toffoli-type 3 qubit gates (n qubit gates) can be built from CNOT-gates and controlled-U gates only with $V^2=U$:</p> <p></p> <p>And 2-qubit Controlled-U Gate operations can be built from CNOTs and suitable chosen single-qubit operations A,B,C for which $ABC=\\mathbb{I}$ and $AXBXC=U$ holds</p> <p></p> <p>Every $U \\in SU(2)$ (Group of $2 \\times 2$ unitaries with determinant 1) can be written as $U=R_x(\\alpha)R_y(\\beta)R_z(\\gamma)$ and or those the one-qubit unitaries would be</p> <p>$A=R_x(\\alpha)R_y\\left(\\frac{\\beta}{2}\\right)$ $B=R_y\\left(\\frac{-\\beta}{2}\\right)R_x\\left(-\\frac{\\gamma + \\alpha}{2}\\right)$ $C=R_x\\left(\\frac{\\gamma - \\alpha}{2}\\right)$</p> <p>A general unitary V can be written as $e^{i \\varphi} U$ where $U$ has determinant 1 and $e^{i \\varphi}$ is a phase this can be achieved by using a Phase gate after the control qubit  Example Hadamard-Gate from iH Gate which can be realized through rotations</p> <p> Example 2)</p> <p>$$ V_k = \\left( \\begin{array}{cccccccc} a &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;   b    \\   &amp;  1     &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        \\   &amp;        &amp; 1      &amp;        &amp;        &amp;        &amp;        &amp;        \\   &amp;        &amp;        &amp; 1      &amp;        &amp;        &amp;        &amp;        \\   &amp;        &amp;        &amp;        &amp; 1      &amp;        &amp;        &amp;        \\   &amp;        &amp;        &amp;        &amp;        &amp; 1      &amp;        &amp;        \\   &amp;        &amp;        &amp;        &amp;        &amp;        &amp; 1      &amp;        \\ c &amp;        &amp;        &amp;        &amp;        &amp;        &amp;        &amp;   d    \\ \\end{array} \\right) \\quad \\begin{array}{c} \\leftarrow |000\\rangle \\ \\leftarrow |001\\rangle \\ \\ \\ \\ \\ \\leftarrow |110\\rangle \\ \\leftarrow |111\\rangle \\end{array} $$</p> <p>Choose the last configuration and construct the unitary as such that it acts on that (Here $|111 \\rangle$). Then note which other configuration it acts on (Here $|110 \\rangle$). Then change one bit at a time from the start configuration (Here $|000 \\rangle$) until you convert to said configuration it usually acts on (Here $|000 \\rangle \\rightarrow |100 \\rangle \\rightarrow |110 \\rangle$). This is called Grey code which connects those states.</p> <p>With the following notation:</p> <p></p> <p>We get the following circuit for our grey code:</p> <p></p> <p>To realize $C^n(U)$ controlled-U operations in an efficient way, where one qubit undergoes U if n others are all in $|1\\rangle$ like in this picture:</p> <p></p> <p>One can use [Toffoli Gate|Toffolis]] to concatenate the control qubits to [Ancilla|Ancillas: </p> <p>Resource Count: - For one 2-level unitary $(d=2^n)$ we need at most $2(n-1)$ controlled operations $C^{n-1}(X)$ to implement the swap of basis states according to the Grey Code, i. e. $O(n)$ of these operations - Resource requirement for such $C^n(U): O(n)$ Toffolis. This amounts to $O(n)$ single qubit and CNOT gates - We saw that we needed at most $O(4^n)$ two-level unitaries $V_i$ to decompose the n-qubit unitary $U$</p> <p>[!RESULT] Implementation of an arbitrary n-qubit unitary U can be realized by a quantum circuit containing $O(n^24^n)$ single-qubit and CNOT gates </p> <ol> <li>Arbitrary single-qubit rotations can be approximated by a finite set of single-qubit gates (e.g. [T-Gate]] and [Hadamard-Gate) A concatenation of Rotations is another Rotation Gates|Rotation with an angle of an irrational multiple of $\\pi$ in the Bloch sphere. Example: $$ \\begin{align} R_z(\\pi/4)R_x(\\pi/4) &amp;= e^{-i\\frac{\\pi}{8}Z}e^{-\\frac{\\pi}{8}X} \\  &amp;=(\\cos\\frac{\\pi}{8}\\mathbb{I}-i \\sin{\\frac{\\pi}{8}}Z)(\\cos\\frac{\\pi}{8}\\mathbb{I}-i \\sin{\\frac{\\pi}{8}}X) \\ &amp;=\\cos^2{\\frac{\\pi}{8}}\\mathbb{I}-i \\cos{\\frac{\\pi}{8}}\\sin{\\frac{\\pi}{8}}X-i\\sin{\\frac{\\pi}{8}}\\cos{\\frac{\\pi}{8}}Z-\\sin^2{\\frac{\\pi}{8}}ZX \\ &amp;=\\cos^2{\\frac{\\pi}{8}}\\mathbb{I}-i \\sin{\\frac{\\pi}{8}}(\\cos{\\frac{\\pi}{8}}(X+Z)+\\sin{\\frac{\\pi}{8}Y}) \\ &amp;= \\cos{\\frac{\\theta}{2}}\\mathbb{I}-i \\sin{\\frac{\\theta}{2}}(\\vec{n} \\cdot \\vec{\\sigma}) = R_\\vec{n}(\\theta) \\end{align} $$ With $\\vec{n}=(\\cos\\frac{\\pi}{8},\\sin\\frac{\\pi}{8},\\cos\\frac{\\pi}{8})$  $\\cos\\frac{\\theta}{2}=\\cos^2\\frac{\\pi}{8}$ is a transcendental equation, this means that $\\theta$ is an irrational multiple of $\\pi$. That is why we never revisit the same point on the circle! $\\Rightarrow$ We can get arbitrarily close to any point in the circle $\\Rightarrow$ The circle is densely covered We can construct another orthogonal vector (which are linearly independent) with Hadamard-Gate|H-Gates:  $R_\\vec{m}(\\theta)=HR_\\vec{n}(\\theta)H$ Where we used the identities of the Hadamard for [X Gate|X]],[[Y Gate|Y]] and [Z Gate|Z Gates. Arbitrary single-qubit rotations can be built up from rotations about two axes as: $U=e^{i \\alpha}R_\\vec{n}(\\beta)R_\\vec{m}(\\gamma)R_\\vec{n}(\\delta)$ $\\Rightarrow$ Thus, we can approximate an arbitrary single-qubit operation $U$ by only [Hadamard-Gate|H]] and [T-Gate|T. The efficiency of the approximation is given by the Solovay-Kitaev-Theorem. For a given small desired error $\\varepsilon$, a few rotations are sufficient to quickly get close to the desired $U$.  Due to the [Gottesmann-Knill theorem]] any [Clifford Gates|Clifford Gate can be perfectly simulated efficiently.</li> </ol>"},{"location":"Gates/Single-qubit%20gates/Hadamard-Gate/","title":"Hadamard Gate","text":"<p>The Hadamard-Gate is as follows:</p> <p>$H = \\frac{1}{\\sqrt{2}} \\begin{pmatrix}  1 &amp; 1 \\  1 &amp; -1  \\end{pmatrix}$</p> <p>The Hadamard Gate maps the Z-eigenstates to the X-Eigenstates and vice versa. The Hadamard Gate is unitary and hermitian.</p>"},{"location":"Gates/Single-qubit%20gates/Hadamard-Gate/#identities","title":"Identities","text":"<p>The Hadamard-Gate can be built from Rotation Gates like this: $H = R_z(\\pi) \\cdot R_y(-\\frac{\\pi}{2})$ $H = R_x(\\pi) \\cdot R_y(\\frac{\\pi}{2})$</p>"},{"location":"Gates/Single-qubit%20gates/Hadamard-Gate/#common-operations","title":"Common Operations","text":"<p>$H \\ket{0} = \\frac{1}{\\sqrt{2}} ( \\ket{0} + \\ket{1}) = \\ket{+}$ $H \\ket{1} = \\frac{1}{\\sqrt{2}} ( \\ket{0} - \\ket{1}) = \\ket{-}$ Since $H^2= \\mathbb{1}$: $H \\ket{+} = \\ket{0}$ $H \\ket{-} = \\ket{1}$</p> <p>With n-Hadamard gates on $|0 \\rangle$ one can build an equal-weight superposition of all basis states on n qubits $H^{\\otimes n} |0 \\rangle= \\frac{1}{\\sqrt{2^n}} \\sum_{i \\in {0,1}^n} |i \\rangle$ In general applying $H^{\\otimes n}$ to an arbitrary basis state $|i \\rangle$ with $i \\in { 0,1}^n$ the following holds: $H^{\\otimes n} |i \\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{j \\in {0,1}^n} (-1)^{i \\cdot j} |j \\rangle$, with $i \\cdot j = \\sum_{k=1}^n i_n j_n$ as the inner product of the n-bit strings $i,j \\in {0,1}^n$ Example: $$ \\begin{align} H^{\\otimes 2} |01 \\rangle &amp;=  \\frac{1}{\\sqrt{2^n}} \\sum_{j \\in {0,1}^n} (-1)^{01 \\cdot j} |j \\rangle\\ &amp;= \\frac{1}{2}((-1)^{01 \\cdot 00} | 00 \\rangle + (-1)^{01 \\cdot 01} | 01 \\rangle + (-1)^{01 \\cdot 10} | 10 \\rangle + (-1)^{01 \\cdot 11} | 11 \\rangle) \\ &amp;= \\frac{1}{2} (|00\\rangle - |01\\rangle + |10\\rangle - |11\\rangle) \\ &amp;= \\frac{1}{\\sqrt{2}} (|0 \\rangle + |1 \\rangle ) \\otimes \\frac{1}{\\sqrt{2}} (|0 \\rangle - |1 \\rangle) \\end{align} $$</p>"},{"location":"Gates/Single-qubit%20gates/Hadamard-Gate/#qiskit","title":"Qiskit","text":"<pre><code>qc.h(qr[0]) # execute H-gate on qubit 0\n</code></pre>"},{"location":"Gates/Single-qubit%20gates/Phase-Gate/","title":"Phase Gate","text":"<p>The Phase-Gate S is as follows:</p> <p>$X = \\begin{pmatrix}  1 &amp; 0 \\  0 &amp; i  \\end{pmatrix}$</p>"},{"location":"Gates/Single-qubit%20gates/Phase-Gate/#identities","title":"Identities","text":"<p>The Phase-Gate can be built from the T-Gate|T-Gates:</p> <p>$S = T^2$</p>"},{"location":"Gates/Single-qubit%20gates/Phase-Gate/#qiskit","title":"Qiskit","text":"<pre><code>qc.s(qr[0]) # execute phase gate on qubit 0\nqc.sdg(qr[0]) # execute conjugate transpose of the S gate on qubit 0\n</code></pre>"},{"location":"Gates/Single-qubit%20gates/Single-qubit%20gates/","title":"Single qubit gates","text":"<p>For classical bits there is only one non-trivial gate, the NOT gate. For qubits there are infinite possible gates. For example the [Pauli Gates]], the [[Hadamard-Gate]], [[Phase-Gate]] and [T-Gate.</p>"},{"location":"Gates/Single-qubit%20gates/T-Gate/","title":"T Gate","text":"<p>The T-Gate is as follows:</p> <p>$T = \\begin{pmatrix}  1 &amp; 0 \\  0 &amp; e^{i\\pi/4}  \\end{pmatrix}$</p>"},{"location":"Gates/Single-qubit%20gates/T-Gate/#identities","title":"Identities","text":"<p>The Phase Gate S can be built from the T-Gate|T-Gates:</p> <p>$S = T^2 = \\begin{pmatrix}  1 &amp; 0 \\  0 &amp; i  \\end{pmatrix}$  </p> <p>The T-Gate is a specific Rz gate(up to phase): $T= e^{i \\pi / 8} R_Z(\\pi/4)$</p>"},{"location":"Gates/Single-qubit%20gates/T-Gate/#qiskit","title":"Qiskit","text":"<pre><code>qc.t(qr[0]) # execute Z gate on qubit 0\nqc.tdg(qr[0]) # execute conjugate transpose of the T gate on qubit 0\n</code></pre>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Identity%20Gate/","title":"Identity Gate","text":"<p>The Identity Gate is as follows:</p> <p>$\\mathbb{I} = \\begin{pmatrix}  1 &amp; 0 \\  0 &amp; 1  \\end{pmatrix}$</p> <p>It does essentially nothing</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Identity%20Gate/#identities","title":"Identities","text":"<p>$X^2 = Y^2 = Z^2 = \\mathbb{I}$</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Pauli%20Gates/","title":"Pauli Gates","text":"<p>[Identity Gate]], [[X Gate]], [[Y Gate]] and [Z Gate are Pauli Gates.</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Pauli%20Gates/#identities","title":"Identities","text":"<p>$X^2 = Y^2 = Z^2 = -iXYZ = \\mathbb{1}$ $ZX = iY = -XZ$</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/X%20Gate/","title":"X Gate","text":"<p>The X Gate is as follows:</p> <p>$X = \\begin{pmatrix}  0 &amp; 1 \\  1 &amp; 0  \\end{pmatrix}$</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/X%20Gate/#identities","title":"Identities","text":"<p>The X Gate can be built from the [Z Gate]] and [Hadamard-Gate|H-Gates:</p> <p>$X = HZH$</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/X%20Gate/#qiskit","title":"Qiskit","text":"<pre><code>qc.x(qr[0]) # execute X-gate on qubit 0\n</code></pre>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/X%20Gate/#eigenstates","title":"Eigenstates","text":"<p>$|+ \\rangle = \\frac{1}{\\sqrt{2}} (|0\\rangle + |1 \\rangle)$ $|- \\rangle = \\frac{1}{\\sqrt{2}} (|0\\rangle - |1 \\rangle)$</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Y%20Gate/","title":"Y Gate","text":"<p>The Y Gate is as follows:</p> <p>$Y = \\begin{pmatrix}  0 &amp; -i \\  i &amp; 0  \\end{pmatrix}$</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Y%20Gate/#identities","title":"Identities","text":"<p>The Y Gate can be built from itself and Hadamard-Gate|H-Gates:</p> <p>$-Y = HYH$</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Y%20Gate/#qiskit","title":"Qiskit","text":"<pre><code>qc.y(qr[0]) # execute Y-gate on qubit 0\n</code></pre>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Y%20Gate/#eigenstates","title":"Eigenstates","text":"<p>$|+ \\rangle_i = \\frac{1}{\\sqrt{2}} (|0\\rangle + i|1 \\rangle)$ $|- \\rangle_i = \\frac{1}{\\sqrt{2}} (|0\\rangle - i|1 \\rangle)$</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Z%20Gate/","title":"Z Gate","text":"<p>The Z Gate is as follows:</p> <p>$Z = \\begin{pmatrix}  1 &amp; 0 \\  0 &amp; -1  \\end{pmatrix}$</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Z%20Gate/#identities","title":"Identities","text":"<p>The Z Gate can be built from the [X Gate]] and [Hadamard-Gate|Hadamard-Gates:</p> <p>$Z = HXH$</p> <p>It can also be built from Rz gate: $Z=iR_z(\\pi)$</p> <p>The Z-Gate can also be built from the T-Gate: $Z = T^4= iR_z(\\pi)$</p>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Z%20Gate/#qiskit","title":"Qiskit","text":"<pre><code>qc.z(qr[0]) # execute Z-gate on qubit 0\n</code></pre>"},{"location":"Gates/Single-qubit%20gates/Pauli%20Gates/Z%20Gate/#eigenstates","title":"Eigenstates","text":"<p>$|0 \\rangle$ $|1 \\rangle$</p>"},{"location":"Gates/Single-qubit%20gates/Rotation%20Gates/Rotation%20Gates/","title":"Rotation Gates","text":"<p>Rotation Gates can be built from Pauli Gates like this:</p> <p>$R_\\sigma (\\alpha) = \\exp(-\\frac{i \\alpha}{2} \\sigma)$ With deconstructing the Pauli matrices in the Taylor representation the following holds: $R_\\sigma (\\alpha) = \\cos\\left(\\frac{\\alpha}{2}\\right) \\mathbb{1} - i \\sin\\left(\\frac{\\alpha}{2}\\right) \\sigma$ An arbitrary rotation on the Bloch sphere can be described as $R_\\vec{n}(\\alpha) = \\exp\\left(\\frac{i \\alpha}{2} \\vec{n} \\cdot \\vec{\\sigma}\\right)=\\cos{\\frac{\\alpha}{2}}\\mathbb{I}-i \\sin{\\frac{\\alpha}{2}}(\\vec{n} \\cdot \\vec{\\sigma})$ with $\\vec{n} \\cdot \\vec{\\sigma} = n_x X + n_y Y + n_z Z$. Arbitrary single-qubit rotations can be built up from rotations about two axes as: $U=e^{i \\alpha}R_\\vec{n}(\\beta)R_\\vec{m}(\\gamma)R_\\vec{n}(\\delta)$</p>"},{"location":"Gates/Single-qubit%20gates/Rotation%20Gates/Rx%20Gate/","title":"Rx Gate","text":"<p>The Rx gate is one of the Rotation Gates. The Rx gate is a single-qubit rotation through angle\u00a0$\\varphi$\u00a0(radians) around the x-axis.</p> <p>$R_x(\\varphi) = \\begin{pmatrix}  \\cos\\left(\\frac{\\varphi}{2}\\right) &amp; -i\\sin\\left(\\frac{\\varphi}{2}\\right) \\  -i\\sin\\left(\\frac{\\varphi}{2}\\right) &amp; \\cos\\left(\\frac{\\varphi}{2}\\right)  \\end{pmatrix}$</p>"},{"location":"Gates/Single-qubit%20gates/Rotation%20Gates/Rx%20Gate/#identities","title":"Identities","text":"<p>$R_x(\\pi/4)=HTH=HR_z(\\pi/4)H$</p>"},{"location":"Gates/Single-qubit%20gates/Rotation%20Gates/Rx%20Gate/#qiskit","title":"Qiskit","text":"<pre><code>version 1.0\nqubits 2\nH q[0] # execute Hadamard gate on qubit 0\nRx q[0],-1.12  # rotation of -1.12 radians on qubit 0\n</code></pre>"},{"location":"Gates/Single-qubit%20gates/Rotation%20Gates/Ry%20Gate/","title":"Ry Gate","text":"<p>The Ry Gate is one of the Rotation Gates. The Ry gate is a single-qubit rotation through angle $\\varphi$\u00a0(radians) around the y-axis.</p> <p>$R_y(\\varphi) = \\begin{pmatrix}  \\cos\\left(\\frac{\\varphi}{2}\\right) &amp; -\\sin\\left(\\frac{\\varphi}{2}\\right) \\  \\sin\\left(\\frac{\\varphi}{2}\\right) &amp; \\cos\\left(\\frac{\\varphi}{2}\\right)  \\end{pmatrix}$</p>"},{"location":"Gates/Single-qubit%20gates/Rotation%20Gates/Ry%20Gate/#qiskit","title":"Qiskit","text":"<pre><code>version 1.0\nqubits 2\nH q[0] # execute Hadamard gate on qubit 0\nRy q[0],1.78 # Rotation of 1.78 radians around the y-axis on qubit 0\n</code></pre>"},{"location":"Gates/Single-qubit%20gates/Rotation%20Gates/Rz%20gate/","title":"Rz gate","text":"<p>The Rz Gate is one of the Rotation Gates. The Ry gate is a single-qubit rotation through angle $\\varphi$\u00a0(radians) around the z-axis.</p> <p>$R_z(\\varphi) = \\begin{pmatrix}  e^{-i\\frac{\\varphi}{2}} &amp; 0 \\  0 &amp; e^{i\\frac{\\varphi}{2}}  \\end{pmatrix}$</p>"},{"location":"Gates/Single-qubit%20gates/Rotation%20Gates/Rz%20gate/#identities","title":"Identities","text":"<p>$R_z(\\theta)=R_x(\\pi/2)R_y(\\theta)R_x(-\\pi/2)$</p>"},{"location":"Gates/Single-qubit%20gates/Rotation%20Gates/Rz%20gate/#qiskit","title":"Qiskit","text":"<pre><code>version 1.0\nqubits 2\nH q[0] # execute Hadamard gate on qubit 0\nRz q[0],-1.12 # rotation around z-axis of -1.12 radians on qubit 0\n</code></pre>"},{"location":"Gates/Two-qubit%20gates/CNOT%20gate/","title":"CNOT gate","text":"<p>The CNOT gate (or Controlled-NOT gate) is two-qubit operation, where the first qubit is usually referred to as the control qubit and the second qubit as the target qubit. Expressed in basis states, the CNOT gate:</p> <ul> <li>leaves the control qubit unchanged and performs a Pauli-X gate on the target qubit when the control qubit is in state\u00a0$\\ket{1}$;</li> <li>leaves the target qubit unchanged when the control qubit is in state\u00a0$\\ket{0}$.</li> <li>is equivalent to adding the value of the control qubit qubit to the value of the second qubit, and writing the result into the second qubit<ul> <li>$\\ket{a,b} \\overset{CNOT}\\longrightarrow \\ket{a,b \\oplus a}$</li> </ul> </li> </ul> <p>$CNOT = \\begin{pmatrix}  1 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 1 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1 \\  0 &amp; 0 &amp; 1 &amp; 0 \\end{pmatrix}$ </p>"},{"location":"Gates/Two-qubit%20gates/CNOT%20gate/#qiskit","title":"Qiskit","text":"<pre><code>qc.cx(qr[0], qr[1]) # execute CNOT gate with control qubit 0 and target qubit 1\n</code></pre>"},{"location":"Gates/Two-qubit%20gates/Controlled-U%20Gate/","title":"Controlled U Gate","text":"<p>U is applied to the second qubit if and only if the first qubit is in state $|1 \\rangle$. The CNOT gate is a Controlled-X Gate.</p> <p></p>"},{"location":"Gates/Two-qubit%20gates/SWAP%20Gate/","title":"SWAP Gate","text":"<p>The swap gate swaps two qubits and can be constructed by a concatenation of CNOT gate|CNOTs.</p> <p></p>"},{"location":"Gates/Two-qubit%20gates/Toffoli%20Gate/","title":"Toffoli Gate","text":"<p>The three-bit Toffoli Gate is a universal reversible logical gate: any reversible circuit can be built from Toffoli gates only. The NOT gate can be realized by $a=b=1$ and the AND gate by $c=0$</p> <p>Its action is: Only if the first two input bits are set to 1, the gate inverts the third bit, otherwise the three bits remain all unchanged.</p> <p>Non trivial action: $110 \\rightarrow 111$ $111 \\rightarrow 110$</p> <p></p>"},{"location":"Gates/Two-qubit%20gates/Two-qubit%20gates/","title":"Two qubit gates","text":"<p>A two qubit gate is a Unitary U acting on 2 qubits.</p>"},{"location":"Math/Kronecker%20Delta/","title":"Kronecker Delta","text":""},{"location":"Math/Kronecker%20Delta/#definition","title":"Definition","text":"<p>$$ \\delta_{ij} =</p> <p>\\begin{cases}</p> <p>1 &amp; \\text{if } i = j \\</p> <p>0 &amp; \\text{if } i \\ne j</p> <p>\\end{cases} $$</p>"},{"location":"Math/Kronecker%20Delta/#identity","title":"Identity","text":"<p>The sum of all N N-th roots of 1 always are equal to one (except N=1).  That\u2018s why for $N&gt;1$ the following holds: $$ \\sum_{n=0}^{N-1}e^{2 \\pi i n (j-l)/N}=N\\cdot \\delta_{jl} $$</p>"},{"location":"Math/Trace/","title":"Trace","text":"<p>The trace of any operator is the sum of diagonal elements in any orthonormal basis. $\\mathrm{tr}=\\sum_{y=1}^d \\langle \\varphi_y | \\rho | \\varphi_y \\rangle, \\langle \\varphi_y | \\varphi_{y\u2019} \\rangle = \\delta_{yy\u2019} \\Rightarrow \\sum_y | \\varphi_y \\rangle \\langle \\varphi_y | = \\mathbb{I}$</p> <p>The trace has cyclic properties: $\\mathrm{tr}(AB)=\\mathrm{tr}(BA)$ $\\mathrm{tr}(|a\\rangle \\langle b |)=\\langle b | a \\rangle$ $\\mathrm{tr}(|a\\rangle \\langle b |A)=\\langle b |A| a \\rangle=\\mathrm{tr}(A|a\\rangle \\langle b |)$</p> <p>The trace equals the sum of diagonal elements in any complete set of $n\\geq d$ vectors $\\mathrm{tr}=\\sum_{y=1}^n \\langle \\pi_y | \\rho | \\pi_y \\rangle, \\sum_y | \\pi_y \\rangle \\langle \\pi_y | = \\mathbb{I}$</p> <p>The partial trace is calculated as follows: $\\mathrm{tr}B(\\rho{AB})=\\sum_j(\\mathbb{I}A\\otimes\\langle j |)\\rho{AB}(\\mathbb{I}_A\\otimes| j\\rangle)=\\rho_A$</p>"},{"location":"Quantum%20Mechanics/Bloch%20sphere/","title":"Bloch sphere","text":"<p>The Bloch sphere is a three dimensional representation of a two-level quantum mechanical system. The Hilbert Space is two dimensional and the representation is a sphere. Each point of outside and inside the sphere represents a valid state. The Sphere has a radius of 1. For qubits the North Pole of the sphere is the $| 0 \\rangle$ state, the South Pole the $| 1 \\rangle$ state. Those are the eigenstates of the [Z Gate]]. On the positive end of the x-axis the state is the $| + \\rangle$- state, on the negative end the $|- \\rangle$- state. Those are the eigenstates of the [[X Gate]]. For the y-axis those are $| + \\rangle_i$- state, on the negative end the $|- \\rangle_i$- state. Those are the eigenstates of the [[Y Gate]]. States on the surface of the Bloch sphere are [[Pure states]]. States inside the Bloch sphere are [[Mixed States]]. The state in the origin of the Bloch sphere is a [Maximally mixed state.  A pure state in the Bloch sphere can be represented as follows: $| \\Psi \\rangle = e^{i \\gamma} \\left(\\cos{\\frac{\\theta}{2}} | 0 \\rangle + e^{i \\phi} \\sin{\\frac{\\theta}{2}} | 1 \\rangle \\right)$   $\\theta \\in [0, \\pi]$   $\\phi \\in [0,2 \\pi)$</p>"},{"location":"Quantum%20Mechanics/Bloch%20sphere/#rotations","title":"Rotations","text":"<p>Rotations on the Bloch sphere are realized by the Rotation Gates, which can transform any pure state into another states on the Bloch sphere. An arbitrary rotation can be described as $R_\\vec{n}(\\alpha) = \\exp\\left(\\frac{i \\alpha}{2} \\vec{n} \\cdot \\vec{\\sigma}\\right)=\\cos{\\frac{\\alpha}{2}}\\mathbb{I}-i \\sin{\\frac{\\alpha}{2}}(\\vec{n} \\cdot \\vec{\\sigma})$ with $\\vec{n} \\cdot \\vec{\\sigma} = n_x X + n_y Y + n_z Z$.  </p> <p></p>"},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/","title":"Observations on Preperations","text":""},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#open-systems","title":"Open Systems","text":""},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#marginal-preparation-and-conditional-observation-probabilities","title":"Marginal preparation and conditional observation probabilities","text":"<p>The joint probability is the conditional times the marginal probability. The marginal probability of preparation equals the operator trace norm, while the conditional observation probability is obtained using deterministic state with trace-normalized operator. A preperation device is deterministic (probabilistic) with $1 (\\geq 2)$ outcome(s), iff its marginal probability = $1(&lt;1)$. </p>"},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#post-selection","title":"Post-selection","text":"<p>Normalization of a preparation by post-selection reverses the information flow to / from the lab. This makes the probabilistic device deterministic by changing the outcome to the device label. This means that we wait until the prepared state that is wanted gets triggered. To obtain the deterministic preperation $\\hat{\\rho}{A|x}$ one needs to trace-normalize $\\rho{Ax}$. This describes the conditional probabilities of any later observation $\\varepsilon_{Ay}$. $$ \\hat{\\rho}{A|x} = \\frac{1}{\\sum_y p{yx}} \\cdot \\rho_{Ax} = \\frac{1}{p_x} \\cdot \\rho_{Ax} = \\frac{1}{\\mathrm{tr}(\\rho_{Ax})} \\rho_{Ax} $$ By discarding outcomes $y$ we automatically discard the device $\\varepsilon_{Ay}$, eliminating any functional dependence of $p_x$ on this future choice </p>"},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#coarse-graining-a-preparation-test","title":"Coarse-graining a preparation test","text":"<p>It is also possible to coarse-grain over all outcomes to create a deterministic preparation device. Here two outcomes is reduced to one outcome. Discarding preparation outcomes effectively defines a new deterministic preperation device. The effective deterministic preperation $\\hat{\\rho}A$ describes the probabilities generated by any choice of later observation $\\varepsilon{Ay}$ </p>"},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#non-purity","title":"Non-purity","text":""},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#preparations","title":"Preparations","text":""},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#definitions","title":"Definitions","text":"<ol> <li>Preparation probabilities of the reining pure preparations (eigenvalues of operator $\\rho_{Ax}$) </li> <li>The number of refining preparations that contribute with $p_{xx\u2019}\\neq 0$ (rank of operator $\\rho_{Ax}$)     $$     1 \\leq d_{\\rho_{Ax}} = \\text{dim} \\, \\mathcal{H}{\\rho{Ax}} \\leq d_A      $$</li> <li>The subspace spanned by these orthogonal eigenvectors (support space of operator $\\rho_{Ax}$) $$ \\mathcal{H}{\\rho{Ax}} = \\mathrm{span}{|\\varphi_{Ax\u2019x} \\rangle}^{d_{\\rho_{Ax}}}_{x\u2019=1} \\subseteq \\mathcal{H}_A $$</li> </ol>"},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#canonical-coarse-graining-form","title":"Canonical coarse-graining form","text":"<p>Every preperation $\\rho_{Ax}$ (operator) has a canonical coarse-graining simulation (diagonal form with subnormalized eigenvectors). Here we use orthogonal covectors ($\\langle \\varphi_{Ax\u2019,x} | \\varphi_{Ax\u2019\u2019,x} \\rangle \\propto \\delta_{x\u2019\u2019 x\u2019}$).</p> <p>$\\rho_{Ax} = \\sum_{x\u2019=1}^{d_{\\rho_{Ax}}} | \\varphi_{Ax\u2019,x} \\rangle \\langle \\varphi_{Ax\u2019,x} |, \\quad p_x=\\mathrm{tr}A(\\rho{Ax})=\\sum_{x\u2019=1}^{d_{\\rho_{A x}}} \\langle \\varphi_{Ax\u2019,x} | \\varphi_{Ax\u2019,x} \\rangle \\leq 1$</p> <p></p> <p>Thus we can see that the open-system quantum rules are the coarse-graining of closed-system rules (for preperations)</p>"},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#example","title":"Example","text":"<p>$\\rho_{Ax}=\\frac{1}{4}\\mathbb{I}$ can be simulated through coarse-graining with $| \\varphi_{A0,x} \\rangle=\\sqrt{\\frac{1}{4}}|0\\rangle \\quad | \\varphi_{A1,x} \\rangle=\\sqrt{\\frac{1}{4}}|1\\rangle$ $\\Rightarrow \\rho_{Ax}= \\sum_{x\u2019=0,1} | \\varphi_{Ax\u2019,x} \\rangle \\langle \\varphi_{Ax\u2019,x} |= \\frac{1}{4}|0 \\rangle\\langle 0| + \\frac{1}{4}|1 \\rangle\\langle 1|=\\frac{1}{4}\\mathbb{I}$ It can also be simulated through coarse-graining with $| \\varphi_{A+,x} \\rangle=\\sqrt{\\frac{1}{4}}|+\\rangle \\quad | \\varphi_{A-,x} \\rangle=\\sqrt{\\frac{1}{4}}|-\\rangle$ $\\Rightarrow \\rho_{Ax}= \\sum_{x\u2019=\\pm} | \\varphi_{Ax\u2019,x} \\rangle \\langle \\varphi_{Ax\u2019,x} |= \\frac{1}{4}|+ \\rangle\\langle +| + \\frac{1}{4}|- \\rangle\\langle -|=\\frac{1}{4}\\mathbb{I}$</p>"},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#canonical-mixture-form","title":"Canonical mixture form","text":"<p>Every preparation (operator) has a canonical simulation as a mixture which is the diagonal form with normalized eigenvectors.</p> <p>$$ \\rho_{Ax}=\\sum_{x\u2019=1}^{d_{\\rho_{Ax}}} |\\hat{\\varphi}{Ax\u2019|x}\\rangle \\langle \\hat{\\varphi}{Ax\u2019|x}| \\cdot p_{xx\u2019}, \\quad |\\langle \\check{\\varphi}{Ax\u2019\u2019|x}\\rangle|\\hat{\\varphi}{Ax\u2019|x}\\rangle\\rangle|^2= \\delta_{x\u2019\u2019x} $$</p>"},{"location":"Quantum%20Mechanics/Observations%20on%20Preperations/#example_1","title":"Example","text":"<p>For $\\rho_{Ax}=\\frac{1}{4}\\mathbb{I}$ the eigenvectors are $|\\hat{\\varphi}{A0|x}\\rangle=|0\\rangle$ and $|\\hat{\\varphi}{A1|x}\\rangle=|1\\rangle$. Their observations are just $\\dagger$ because they are per definition orthonormal thus perfectly distinguishable. $p_{x0}=\\mathrm{tr}A(|\\check{\\varphi}{Ax\u2019|x}\\rangle \\langle \\check{\\varphi}{Ax\u2019|x} | \\cdot \\rho{Ax})= \\mathrm{tr}(|0\\rangle \\langle 0 |\\cdot \\frac{1}{4} \\mathbb{I})=\\frac{1}{4}$ $p_{x1}=\\mathrm{tr}A(|\\check{\\varphi}{Ax\u2019|x}\\rangle \\langle \\check{\\varphi}{Ax\u2019|x} | \\cdot \\rho{Ax})= \\mathrm{tr}(|1\\rangle \\langle 1 |\\cdot \\frac{1}{4} \\mathbb{I})=\\frac{1}{4}$ $\\Rightarrow \\rho_{Ax}=\\sum_{x\u2019=0,1} |\\hat{\\varphi}{Ax\u2019|x}\\rangle \\langle \\hat{\\varphi}{Ax\u2019|x}| \\cdot p_{xx\u2019}=|0\\rangle \\langle 0 |\\cdot \\frac{1}{4}+|1\\rangle \\langle 1 |\\cdot \\frac{1}{4}=\\frac{1}{4}\\mathbb{I} \\; \\checkmark$</p>"},{"location":"Quantum%20Mechanics/Quantum%20Entanglement/","title":"Quantum Entanglement","text":"<p>If Product States are non-separable they are entangled. They can be semi entangled and fully entangled. All pure states that cannot be written as product states are entangled.</p> <p>Bell states are examples of entangled states</p>"},{"location":"Quantum%20Mechanics/Quantum%20Entanglement/#bell-states","title":"Bell states","text":"<p>Bell states are the simplest maximally entangled states. They form the Bell basis which is a four dimensional Hilbert Space for two qubits: $|\\Phi^+ \\rangle = \\frac{1}{\\sqrt{2}} ( |00 \\rangle + | 11 \\rangle)$  $|\\Phi^- \\rangle = \\frac{1}{\\sqrt{2}} ( |00 \\rangle - | 11 \\rangle)$  $|\\Psi^+ \\rangle = \\frac{1}{\\sqrt{2}} ( |01 \\rangle + | 10 \\rangle)$  $|\\Psi^- \\rangle = \\frac{1}{\\sqrt{2}} ( |10 \\rangle - | 01 \\rangle)$ </p>"},{"location":"Quantum%20Mechanics/Quantum%20dynamics/","title":"Quantum dynamics","text":"<p>The Quantum dynamics or time evolution of a quantum state $| \\Psi \\rangle$ is a map that evolves into $| \\tilde{\\Psi} \\rangle = U |\\Psi \\rangle$ also conserves probability because the time evolution operator U is unitary ($U^\\dagger U =1$): $\\langle \\tilde{\\Psi} |  \\tilde{\\Psi} \\rangle = \\langle \\Psi | U^\\dagger U \\Psi \\rangle = \\langle \\Psi | \\Psi \\rangle = 1$ for any initial state $|\\Psi \\rangle$. In quantum computation all unitary transformations are allowed and represent valid quantum operations.</p> <p>Examples: - Transformations generated by a control Hamiltonian $H_C$ like external control fields (e.g. electromagnetic fields)</p> <p>Basic unitary transformation on single qubits, pairs of qubits and an ensemble on qubits are called [Single-qubit gates]], [[Two-qubit gates]] and [n-qubit gates. </p> <p>The Schr\u00f6dinger equation is as follows (for $H$ time independent): $- i \\hbar \\frac{d}{dt} | \\Psi(t) \\rangle = H | \\Psi(t) \\rangle$ with $| \\Psi(t) \\rangle = U(t) | \\Psi(0) \\rangle$ and $U(t) = \\exp\\left(-\\frac{i H t}{\\hbar} \\right)$</p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/","title":"Rules of Quantum Theory","text":""},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#definitions","title":"Definitions","text":""},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#set-of-rules","title":"Set of Rules","text":"System Set of Rules Elements Probability Generation Events Experiment Information loss Closed Broad Vectors Indirectly from amplitudes pure Special None Open Different Operators Directly Generally non-pure General Some In quantum theory switching between systems is always possible.through purifying and coarse graining respectively. <p>Open quantum systems are obtained from closed quantum systems by discarding information.</p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#operational-circuit","title":"Operational Circuit","text":"<p>An Operational Circuit is directed from right to left and contain no loops. It is drawn as equations are written. It represents the joint probability of outcomes of an experiment as function of the events. All events jointly combine the probability of one possible set of outcomes (zyx) of the experiment. Orthogonal (co)vectors are denoted by the symbol $\\varphi$.</p> <p>Rounded boxes $\\equiv$ Events Single wires $\\equiv$ Quantum Systems Double Wires $\\equiv$ Classical information about outcomes in the lab frame</p> <p>Boxes in time (in series) are connected by single wires (same lab frame) and boxes in space (in parallel) are not connected by single wires (different lab frames)</p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#experiment","title":"Experiment","text":"<p>A complete process involving the composition of quantum events that produce outcomes across multiple spatially separated laboratories, where each lab is accessible to agents who can communicate and condition or control their future choice of quantum operations or measurement devices based on prior information. $\\Rightarrow$ Devices (or events they produce) are distinguished by their number of input and output quantum systems </p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#event","title":"Event","text":"<p>An\u00a0event\u00a0is a specific outcome resulting from one use of a device (like a measurement or operation), chosen among several possible alternatives, and fully described in terms of what happened in the lab during that operation. Preparations are also called states collected into ensembles, are also called Effects collected into positive-operator-valued-measures, POVMs)</p> <p></p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#general","title":"General","text":"<p>Quantum Theory is operationally defined by assigning mathematical objects $m$ to the systems Operational Quantity $Q$ by a set rules ($Q=m$) together with a rule to compute probabilities in the lab frame directly from these objects $p_m=f(m)$. There are three probabilistic concepts important for these rules (not specific to quantum theory): - Probabilistic $\\leftrightarrow$ Deterministic: Number of outcomes (outgoing $\\Downarrow$) - Conditioning outcome $\\rightarrow$ Conditioned choice: Outcomes $\\rightarrow$ Incomes (outgoing $\\Uparrow$) - Non-pure $\\leftrightarrow$ Mixed: Probabilistic simulation with/out conditioning? These concepts are all effected by coarse graining.</p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#probabilistic-leftrightarrow-deterministic","title":"Probabilistic $\\leftrightarrow$ Deterministic","text":"<p>The devices are distinguished by the number of possible set of events (outcomes) that they produce in the lab. A deterministic device only produces one event (thus $\\Downarrow$ is omitted) while a probabilistic device have at least two possible events (thus $\\Downarrow$ is needed to specify). The deterministic device is not providing new information to the system. Those devices are indicated by a hat (e.g. $\\hat{\\psi}$) </p> <p>Coarse Graining (denoted by the \u201egarbage bin\u201c at the end of the double arrow) over all possible events of a probabilistic device produces (or simulates) a deterministic device. The coarse grained device generates the probabilities of the probabilistic device summed over the discarded outcomes. Discarding a system means discarding all outcomes  of any observation test performed on it </p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#conditioning-of-choices","title":"Conditioning of choices","text":"<p>Agents in the lab frame can choose which devices to use in a circuit during a experiment. Once a possible outcome has been chosen and run it collapses into that path. Conditioned choices are noted by an up arrow $\\Uparrow$ and a conditioning bar $|$ for probabilistic devices. For deterministic devices the conditioning bar is not necessary and only the device label is noted. </p> <p>Outcomes produced probabilistically can be used to condition other devices, this is a simulation of a new device which jointly produces all the outcomes. </p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#pure-eventsdevices","title":"Pure events/devices","text":"<p>A pure event is an elementary event which has no underlying non-trivial probabilistic explanation. A pure event can not be simulated non-trivially. The purity of devices is the only operational assumption distinguishing the closed and open system quantum rules. Thus for pure events we use the notation for closed systems in the open system picture to indicate that. All pure events are Rank 1 projectors ($P=P^\\dagger, P=P^2$ or Number of non-zero eigenvalues=1). Operators can only describe pure transformations! E.g. for preparation (This is similar for transformations and observations): $\\sum_{x\u2019}\\rho\u2019{Ax\u2019,x}=\\sum{x\u2019}p_{x\u2019|x}\\psi_{Ax\u2019}=\\psi_{Ax}$  </p> <p></p> <p>Example:     $\\psi_x=|0\\rangle \\langle 0 |$ can not be written as a probabilistic composition other than itself ($\\sum_{x\u2019=0}p_{x\u2019|x}\\psi_{x} =1 \\cdot |0\\rangle \\langle 0 |=\\psi_x$) and has a rank of 1 and is thus pure but $\\rho\u2019x=\\frac{1}{2}(|0\\rangle \\langle 0 |+|1\\rangle \\langle 1 |)$ can be written as a probabilistic composition of other preparations ($\\sum{x\u2019=0,1}p_{x\u2019|x}\\rho_{x} =\\frac{1}{2} \\cdot |0\\rangle \\langle 0 | + \\frac{1}{2} \\cdot |1\\rangle \\langle 1 | =\\rho\u2019_x$) and is thus non-pure. The rank is also 2.</p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#mixed-neq-non-pure","title":"Mixed $\\neq$ Non-pure","text":"<p>Devices that are mixed are always also non-pure, but not all non-pure events are mixed (except for preperations)! A mixed device can be simulated by coarse graining of device choices conditioned on a random variable. Thus the event is not mixed if the probabilities adding up are greater than one ($\\sum_{i}p_i \\geq 1$). $\\sum_{x\u2019}\\rho_{Ax|x\u2019}p_{x\u2019}=\\rho_{Ax}$ Example: - $\\sum_{x=0,1}\\rho_{Ax|x\u2019}p_{x\u2019} =\\frac{1}{2} \\cdot |0\\rangle \\langle 0 | + \\frac{1}{2} \\cdot |1\\rangle \\langle 1 | =\\rho_x$ is a mixed preperation. And as shown before on-pure. - $\\mathbb{I}=|0\\rangle \\langle 0 | + |1\\rangle \\langle 1 |$ is not mixed because 1+1=2. This is also non-pure because the rank is 2. Thus this observation is neither pure nor mixed. </p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#causality","title":"Causality","text":"Open Systems Any event can be non-pure Observation Transformation Preperation Deterministic $\\hat{e}_B=\\mathbb{I}_B$ $\\hat{\\mathcal{T}}_{B,A}$ $\\hat{\\rho}_A$ Test=Event $\\mathrm{tr}_B(\\hat{e}_B\\bullet)=\\mathrm{tr}_B(\\bullet)$ $\\mathrm{tr}B(\\hat{\\mathcal{T}}{B,A}\\bullet)=\\mathrm{tr}_A(\\bullet)$ $\\mathrm{tr}_A(\\hat{\\rho}_A)=1$ $\\uparrow$ coarse grain $\\uparrow$ coarse grain $\\uparrow$ coarse grain Probabilistic ${\\varepsilon_{Bz}}$ ${\\mathcal{T}_{B,Ay}}$ ${\\rho_{Ax}}$ Test $\\mathrm{tr}B(\\sum_z\\varepsilon{Bz}\\bullet)=\\mathrm{tr}_B(\\mathbb{I}_B\\bullet)$ $\\sum_y\\mathrm{tr}B(\\mathcal{T}{B,Ay}\\bullet)=\\mathrm{tr}_A(\\bullet)$ $\\sum_x \\mathrm{tr}A(\\rho{Ax})=1$ Events $\\mathrm{tr}B(\\varepsilon{Bz}\\bullet)\\leq\\mathrm{tr}_B(\\mathbb{I}_B\\bullet)$ $\\mathrm{tr}B(\\mathcal{T}{B,Ay}\\bullet)\\leq\\mathrm{tr}_A(\\bullet)$ $\\mathrm{tr}A(\\rho{Ax})\\leq1$ $\\uparrow$ coarse grain $\\uparrow$ coarse grain $\\uparrow$ coarse grain Relations $\\varepsilon_{Bz}=\\sum_{z\u2019}|\\pi_{Bzz\u2019}\\rangle\\langle\\pi_{Bzz\u2019}|$ $\\mathcal{T}{B,Ay}=\\sum{y\u2019}T_{B,Ayy\u2019}\\bullet T^{\\dagger}_{B,Ayy\u2019}$ $\\rho_{Ax}=\\sum_{x\u2019}|\\psi_{Axx\u2019}\\rangle\\langle\\psi_{Axx\u2019}|$ $\\downarrow$ pure case $\\downarrow$ pure case $\\downarrow$ pure case Closed Systems Every event is pure Observation Transformation Preperation Deterministic (none) $\\hat{T}_{B,A}$ $|\\hat{\\psi}_A\\rangle$ Test=Event (none) $\\hat{T}^{\\dagger}{B,A}\\hat{T}{B,A}=\\mathbb{I}_A$ $\\langle\\hat{\\psi}_A|\\hat{\\psi}_A\\rangle=1$ Probabilistic $\\langle\\pi_{Bz}|$ $T_{B,Ay}$ $|\\psi_{Ax}\\rangle$ Test $\\sum_{z}|\\pi_{Bz}\\rangle\\langle\\pi_{Bz}|=1$ $\\sum_yT^{\\dagger}{B,Ay}T{B,Ay}=\\mathbb{I}_A$ $\\sum_{x}|\\psi_{Ax}\\rangle\\langle\\psi_{Ax}|=1$ Events $|\\pi_{Bz}\\rangle\\langle\\pi_{Bz}|\\leq1$ $T^{\\dagger}{B,Ay}T{B,Ay}\\leq\\mathbb{I}_A$ $|\\psi_{Ax}\\rangle\\langle\\psi_{Ax}|\\leq1$ Note: To check operators against other operators (e.g. $\\varepsilon_{Bz}\\leq\\mathbb{I}B$) you check the eigenvalues against each other(e.g. $\\lambda{\\varepsilon1} \\leq 1, \\lambda_{\\varepsilon2} \\leq 1$). There is no deterministic observation in the closed system."},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#pretty-good-constructions","title":"Pretty Good Constructions","text":"<p>Pretty good constructions reversing the causal order ($\\rho_{Ax} \\rightarrow \\mathrm{tr}(\\bar{\\varepsilon}{Ax} \\bullet)$, $\\mathrm{tr}(\\varepsilon{Ay} \\bullet) \\rightarrow \\bar{\\rho}{Ay}$) are indicated by overbar $\\bar{x}$. The probabilities for the pretty good experiments are the same as for the original experiment. Mind that the order of devices don\u2018t change and use that the Trace is cyclic and the rules for complex conjugate in the braket formalism. In the open system the probabilities and in the closed system the amplitudes stay the same for $\\dagger \\rightarrow T$. Open systems: $\\bar{\\varepsilon}{Ax}=\\left(\\sqrt{\\frac{1}{\\hat{\\rho}A}}\\rho{Ax}\\sqrt{\\frac{1}{\\hat{\\rho}A}}\\right)^{\\dagger} \\geq 0 \\Rightarrow \\sum_x\\bar{\\varepsilon}{Ax}=\\mathbb{I}A$  With $\\hat{\\rho}{A}=\\sum_x\\rho_{Ax}$ assumed invertible $\\bar{\\rho}{Ay}=\\left(\\sqrt{\\hat{\\rho}_A}\\varepsilon{Ay}\\sqrt{\\hat{\\rho}A}\\right)^{\\dagger} \\geq 0 \\Rightarrow \\sum_y\\bar{\\rho}{Ay}=\\mathrm{tr}A(\\hat{\\rho}{Ay})=1$ $\\Rightarrow p_{yx}=\\mathrm{tr}A(\\varepsilon{Ay}\\rho_{Ax})=\\mathrm{tr}A(\\bar{\\rho}{Ay}\\bar{\\varepsilon}{Ax})=\\mathrm{tr}_A(\\bar{\\varepsilon}{Ax}\\bar{\\rho}{Ay})=\\bar{p}{xy}$ Closed systems: $\\langle \\bar{\\pi}{Ax} | = \\langle \\psi{Ax} | \\sqrt{\\frac{1}{\\hat{\\rho}A}}=\\left(\\sqrt{\\frac{1}{\\hat{\\rho}_A}} | \\psi{Ax} \\rangle\\right)^{\\dagger} \\Rightarrow \\sum_x | \\bar{\\pi}{Ax} \\rangle \\langle \\bar{\\pi}{Ax}| =\\sqrt{\\frac{1}{\\hat{\\rho}A}} \\sum_x | \\psi{Ax} \\rangle \\langle \\psi_{Ax}| \\sqrt{\\frac{1}{\\hat{\\rho}A}}=\\mathbb{I}_A$ With $\\hat{\\rho}{A}=\\sum_x|\\psi_{Ax}\\rangle\\langle\\psi_{Ax}|$ assumed invertible $|\\bar{\\psi}{Ay} \\rangle = \\sqrt{\\hat{\\rho}_A} | \\pi{Ay} \\rangle = \\left(\\langle \\pi_{Ay} | \\sqrt{\\hat{\\rho}A} \\right)^\\dagger \\Rightarrow \\sum_y \\langle \\bar{\\psi}{Ay} | \\bar{\\psi}{Ay}\\rangle =\\sum_y \\langle \\pi{Ay} |\\hat{\\rho}A|\\pi{Ay}\\rangle=\\mathrm{tr}A(\\hat{\\rho}_A)=1$ $\\Rightarrow a{yx}=\\langle\\pi_{Ay}|\\psi_{Ax}\\rangle=\\langle\\bar{\\psi}{Ay}|\\bar{\\pi}{Ax}\\rangle=(\\langle\\bar{\\pi}{Ax}|\\bar{\\psi}{Ay}\\rangle)^=(\\bar{a}_{xy})^$ </p>"},{"location":"Quantum%20Mechanics/Rules%20of%20Quantum%20Theory/#perfect-distinguishability","title":"Perfect Distinguishability","text":"<p>Perfectly distingushable preparations and observations are the only ones equal to their adjoint pretty good construction. So preparations and observations seem only the same if one assumes perfect distinguishability $$ \\langle \\check{\\varphi}{Ax}| \\hat{\\varphi}{A|x} \\rangle = \\delta_{yx} \\iff \\begin{cases} \\langle \\overline{\\hat{\\varphi}{A|x}}| = \\left[ \\sqrt{p_x} \\langle\\hat{\\varphi}{A|x}| \\right] \\left[ \\frac{1}{\\sqrt{\\hat{\\rho}A}} \\right] = \\langle \\hat{\\varphi}{A|x}| = \\left( | \\hat{\\varphi}{A|x}|\\rangle \\right)^{\\dagger} \\ |\\overline{\\check{\\varphi}{Ax}} \\rangle = \\left[ \\frac{1}{\\sqrt{p_x}} \\right] \\left[ \\sqrt{\\hat{\\rho}A} |\\check{\\varphi}{Ax} \\rangle \\right] = |\\check{\\varphi}{Ax} \\rangle = \\left( \\langle\\check{\\varphi}{Ax} | \\right)^{\\dagger} \\end{cases} $$ $$\\text{with} \\quad \\hat{\\rho}A := \\sum_x p_x |\\hat{\\varphi}{Ax} \\rangle \\langle \\hat{\\varphi}_{Ax}|$$</p>"}]}